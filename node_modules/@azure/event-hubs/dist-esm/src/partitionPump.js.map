{"version":3,"file":"partitionPump.js","sourceRoot":"","sources":["../../src/partitionPump.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { MessagingError } from \"@azure/core-amqp\";\nimport { OperationOptions, getParentSpan } from \"./util/operationOptions\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { CanonicalCode, Link, Span, SpanKind } from \"@opentelemetry/api\";\nimport { extractSpanContextFromEventData } from \"./diagnostics/instrumentEventData\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\n\n/**\n * @internal\n */\nexport class PartitionPump {\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: CommonEventProcessorOptions;\n  private _receiver: EventHubReceiver | undefined;\n  private _isReceiving: boolean = false;\n  private _isStopped: boolean = false;\n  private _abortController: AbortController;\n  constructor(\n    private _context: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    private readonly _startPosition: EventPosition,\n    options: CommonEventProcessorOptions\n  ) {\n    this._partitionProcessor = partitionProcessor;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch (err) {\n      // swallow the error from the user-defined code\n      this._partitionProcessor.processError(err);\n    }\n\n    // this is intentionally not await'd - the _receiveEvents loop will continue to\n    // execute and can be stopped by calling .stop()\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    logger.info(\n      `Successfully started the receiver for partition \"${this._partitionProcessor.partitionId}\".`\n    );\n  }\n\n  /**\n   * Creates a new `EventHubReceiver` and replaces any existing receiver.\n   * @param partitionId - The partition the receiver should read messages from.\n   * @param lastSeenSequenceNumber - The sequence number to begin receiving messages from (exclusive).\n   * If `-1`, then the PartitionPump's startPosition will be used instead.\n   */\n  private _setOrReplaceReceiver(\n    partitionId: string,\n    lastSeenSequenceNumber: number\n  ): EventHubReceiver {\n    // Determine what the new EventPosition should be.\n    // If this PartitionPump has received events, we'll start from the last\n    // seen sequenceNumber (exclusive).\n    // Otherwise, use the `_startPosition`.\n    const currentEventPosition: EventPosition =\n      lastSeenSequenceNumber >= 0\n        ? {\n            sequenceNumber: lastSeenSequenceNumber,\n            isInclusive: false\n          }\n        : this._startPosition;\n\n    // Set or replace the PartitionPump's receiver.\n    this._receiver = new EventHubReceiver(\n      this._context,\n      this._partitionProcessor.consumerGroup,\n      partitionId,\n      currentEventPosition,\n      {\n        ownerLevel: this._processorOptions.ownerLevel,\n        trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties,\n        retryOptions: this._processorOptions.retryOptions\n      }\n    );\n\n    return this._receiver;\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    let lastSeenSequenceNumber = -1;\n    let receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n\n    while (this._isReceiving) {\n      try {\n        // Check if the receiver was closed so we can recreate it.\n        if (receiver.isClosed) {\n          receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n        }\n\n        const receivedEvents = await receiver.receiveBatch(\n          this._processorOptions.maxBatchSize,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal\n        );\n\n        if (\n          this._processorOptions.trackLastEnqueuedEventProperties &&\n          receiver.lastEnqueuedEventProperties\n        ) {\n          this._partitionProcessor.lastEnqueuedEventProperties =\n            receiver.lastEnqueuedEventProperties;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n\n        if (receivedEvents.length) {\n          lastSeenSequenceNumber = receivedEvents[receivedEvents.length - 1].sequenceNumber;\n        }\n\n        const span = createProcessingSpan(\n          receivedEvents,\n          {\n            eventHubName: this._context.config.entityPath,\n            host: this._context.config.host\n          },\n          this._processorOptions\n        );\n\n        await trace(() => this._partitionProcessor.processEvents(receivedEvents), span);\n      } catch (err) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        logger.warning(\n          `An error was thrown while receiving or processing events on partition \"${this._partitionProcessor.partitionId}\"`\n        );\n        logErrorStackTrace(err);\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err);\n        } catch (errorFromUser) {\n          // Using verbose over warning because this error is swallowed.\n          logger.verbose(\"An error was thrown by user's processError method: \", errorFromUser);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.code === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (errorFromStop) {\n            // Using verbose over warning because this error is swallowed.\n            logger.verbose(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              errorFromStop\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    if (this._isStopped) {\n      return;\n    }\n    this._isStopped = true;\n    this._isReceiving = false;\n    try {\n      // Trigger the cancellation before closing the receiver,\n      // otherwise the receiver will remove the listener on the abortSignal\n      // before it has a chance to be emitted.\n      this._abortController.abort();\n\n      if (this._receiver) {\n        await this._receiver.close();\n      }\n      await this._partitionProcessor.close(reason);\n    } catch (err) {\n      logger.warning(`An error occurred while closing the receiver: ${err?.name}: ${err?.message}`);\n      logErrorStackTrace(err);\n      this._partitionProcessor.processError(err);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function createProcessingSpan(\n  receivedEvents: ReceivedEventData[],\n  eventHubProperties: { eventHubName: string; host: string },\n  options?: OperationOptions\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedEvent of receivedEvents) {\n    const spanContext = extractSpanContextFromEventData(receivedEvent);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      context: spanContext,\n      attributes: {\n        enqueuedTime: receivedEvent.enqueuedTimeUtc.getTime()\n      }\n    });\n  }\n\n  const span = getTracer().startSpan(\"Azure.EventHubs.process\", {\n    kind: SpanKind.CONSUMER,\n    links,\n    parent: getParentSpan(options?.tracingOptions)\n  });\n\n  span.setAttributes({\n    \"az.namespace\": \"Microsoft.EventHub\",\n    \"message_bus.destination\": eventHubProperties.eventHubName,\n    \"peer.address\": eventHubProperties.host\n  });\n\n  return span;\n}\n\n/**\n * @internal\n */\nexport async function trace(fn: () => Promise<void>, span: Span): Promise<void> {\n  try {\n    await fn();\n    span.setStatus({ code: CanonicalCode.OK });\n  } catch (err) {\n    span.setStatus({\n      code: CanonicalCode.UNKNOWN,\n      message: err.message\n    });\n    throw err;\n  } finally {\n    span.end();\n  }\n}\n"]}