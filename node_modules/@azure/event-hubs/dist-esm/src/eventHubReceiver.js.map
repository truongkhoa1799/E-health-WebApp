{"version":3,"file":"eventHubReceiver.js","sourceRoot":"","sources":["../../src/eventHubReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport {\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverOptions as RheaReceiverOptions,\n  types\n} from \"rhea-promise\";\nimport {\n  Constants,\n  MessagingError,\n  delay,\n  translate,\n  RetryConfig,\n  RetryOperationType,\n  retry\n} from \"@azure/core-amqp\";\nimport { EventDataInternal, ReceivedEventData, fromRheaMessage } from \"./eventData\";\nimport { EventHubConsumerOptions } from \"./models/private\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\n\n/**\n * @hidden\n */\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEvent;\n  onError: OnAmqpEvent;\n  onClose: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSessionClose: OnAmqpEvent;\n  newName?: boolean;\n  eventPosition?: EventPosition;\n}\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/**\n * Describes the message handler signature.\n * @internal\n */\nexport type OnMessage = (eventData: ReceivedEventData) => void;\n\n/**\n * Describes the error handler signature.\n * @internal\n */\nexport type OnError = (error: MessagingError | Error) => void;\n\n/**\n * Describes the abort handler signature.\n * @internal\n */\nexport type OnAbort = () => void;\n\n/**\n * Describes the EventHubReceiver that will receive event data from EventHub.\n * @internal\n */\nexport class EventHubReceiver extends LinkEntity {\n  /**\n   * The EventHub consumer group from which the receiver will\n   * receive messages. (Default: \"default\").\n   */\n  consumerGroup: string;\n  /**\n   * The receiver runtime info.\n   */\n  runtimeInfo: LastEnqueuedEventProperties;\n  /**\n   * The Receiver ownerLevel.\n   */\n  ownerLevel?: number;\n  /**\n   * The event position in the partition at which to start receiving messages.\n   */\n  eventPosition: EventPosition;\n  /**\n   * Optional properties that can be set while creating\n   * the EventHubConsumer.\n   */\n  options: EventHubConsumerOptions;\n  /**\n   * The RHEA AMQP-based receiver link.\n   */\n  private _receiver?: Receiver;\n  /**\n   * The message handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onMessage?: OnMessage;\n  /**\n   * The error handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onError?: OnError;\n  /**\n   * The abort handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onAbort?: OnAbort;\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal cancelling a receiver operation.\n   */\n  private _abortSignal?: AbortSignalLike;\n  /**\n   * The sequence number of the most recently received AMQP message.\n   */\n  private _checkpoint: number = -1;\n  /**\n   * A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`\n   */\n  private _internalQueue: ReceivedEventData[] = [];\n  /**\n   * Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`\n   */\n  private _usingInternalQueue: boolean = false;\n  /**\n   * Indicates if messages are being received from this receiver.\n   */\n  private _isReceivingMessages: boolean = false;\n  /**\n   * Indicated if messages are being received in streaming mode.\n   */\n  private _isStreaming: boolean = false;\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  /**\n   * Returns sequenceNumber of the last event received from the service. This will not match the\n   * last event received by `EventHubConsumer` when the `_internalQueue` is not empty\n   * @readonly\n   */\n  get checkpoint(): number {\n    return this._checkpoint;\n  }\n\n  /**\n   * Indicates if messages are being received from this receiver.\n   * @readonly\n   */\n  get isReceivingMessages(): boolean {\n    return this._isReceivingMessages;\n  }\n\n  /**\n   * Indicates if the receiver has been closed.\n   */\n  get isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /**\n   * The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventProperties` option is set to true\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this.runtimeInfo;\n  }\n\n  /**\n   * Instantiates a receiver that can be used to receive events over an AMQP receiver link in\n   * either batching or streaming mode.\n   * @hidden\n   * @param context -        The connection context corresponding to the EventHubClient instance\n   * @param consumerGroup -  The consumer group from which the receiver should receive events from.\n   * @param partitionId -    The Partition ID from which to receive.\n   * @param eventPosition -  The position in the stream from where to start receiving events.\n   * @param options -      Receiver options.\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options: EventHubConsumerOptions = {}\n  ) {\n    super(context, {\n      partitionId: partitionId,\n      name: context.config.getReceiverAddress(partitionId, consumerGroup)\n    });\n    this.consumerGroup = consumerGroup;\n    this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);\n    this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);\n    this.ownerLevel = options.ownerLevel;\n    this.eventPosition = eventPosition;\n    this.options = options;\n    this.runtimeInfo = {};\n  }\n\n  private _onAmqpMessage(context: EventContext): void {\n    if (!context.message) {\n      return;\n    }\n\n    const data: EventDataInternal = fromRheaMessage(context.message);\n    const receivedEventData: ReceivedEventData = {\n      body: defaultDataTransformer.decode(context.message.body),\n      properties: data.properties,\n      offset: data.offset!,\n      sequenceNumber: data.sequenceNumber!,\n      enqueuedTimeUtc: data.enqueuedTimeUtc!,\n      partitionKey: data.partitionKey!,\n      systemProperties: data.systemProperties\n    };\n\n    this._checkpoint = receivedEventData.sequenceNumber;\n\n    if (this.options.trackLastEnqueuedEventProperties && data) {\n      this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;\n      this.runtimeInfo.enqueuedOn = data.lastEnqueuedTime;\n      this.runtimeInfo.offset = data.lastEnqueuedOffset;\n      this.runtimeInfo.retrievedOn = data.retrievalTime;\n    }\n\n    // Add to internal queue if\n    // - There are no listeners, we are probably getting events due to pending credits\n    // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained\n    if (!this._onMessage || this._usingInternalQueue) {\n      this._internalQueue.push(receivedEventData);\n    } else {\n      if (this._isStreaming) {\n        this._addCredit(1);\n      }\n      this._onMessage(receivedEventData);\n    }\n  }\n\n  private _onAmqpError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    const amqpError = rheaReceiver && rheaReceiver.error;\n    logger.verbose(\n      \"[%s] 'receiver_error' event occurred on the receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      amqpError\n    );\n\n    if (this._onError && amqpError) {\n      const error = translate(amqpError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private _onAmqpSessionError(context: EventContext): void {\n    const sessionError = context.session && context.session.error;\n    logger.verbose(\n      \"[%s] 'session_error' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      sessionError\n    );\n\n    if (this._onError && sessionError) {\n      const error = translate(sessionError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private async _onAmqpClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s'. \" +\n        \"Value for isItselfClosed on the receiver is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'receiver_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  private async _onAmqpSessionClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'session_close' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"Value for isSessionItselfClosed on the session is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isSessionItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'session_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  async abort(): Promise<void> {\n    const desc: string =\n      `[${this._context.connectionId}] The receive operation on the Receiver \"${this.name}\" with ` +\n      `address \"${this.address}\" has been cancelled by the user.`;\n    // Cancellation is user-intended, so log to info instead of warning.\n    logger.info(desc);\n    if (this._onError) {\n      const error = new AbortError(\"The receive operation has been cancelled by the user.\");\n      this._onError(error);\n    }\n    this.clearHandlers();\n    await this.close();\n  }\n\n  /**\n   * Clears the user-provided handlers and updates the receiving messages flag.\n   * @hidden\n   */\n  clearHandlers(): void {\n    if (this._abortSignal && this._onAbort) {\n      this._abortSignal.removeEventListener(\"abort\", this._onAbort);\n    }\n\n    this._abortSignal = undefined;\n    this._onAbort = undefined;\n    this._onError = undefined;\n    this._onMessage = undefined;\n    this._isReceivingMessages = false;\n    this._isStreaming = false;\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   * @hidden\n   */\n  async close(): Promise<void> {\n    try {\n      this.clearHandlers();\n\n      if (!this._receiver) {\n        return;\n      }\n\n      const receiverLink = this._receiver;\n      this._deleteFromCache();\n      await this._closeLink(receiverLink);\n    } catch (err) {\n      const msg = `[${this._context.connectionId}] An error occurred while closing receiver ${this.name}: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @hidden\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._receiver && this._receiver.isOpen());\n    logger.verbose(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers the user's onMessage and onError handlers.\n   * Sends buffered events from the queue before adding additional credits to the AMQP link.\n   * @hidden\n   */\n  registerHandlers(\n    onMessage: OnMessage,\n    onError: OnError,\n    maximumCreditCount: number,\n    isStreaming: boolean,\n    abortSignal?: AbortSignalLike,\n    onAbort?: OnAbort\n  ): void {\n    this._abortSignal = abortSignal;\n    this._onAbort = onAbort;\n    this._onError = onError;\n    this._onMessage = onMessage;\n    this._isStreaming = isStreaming;\n    // indicate that messages are being received.\n    this._isReceivingMessages = true;\n\n    this._useInternalQueue(onMessage, abortSignal)\n      .then(async (processedEventCount) => {\n        if (this._onMessage !== onMessage) {\n          // the original handler has been removed, so no further action required.\n          return;\n        }\n\n        // check if more messages are required\n        if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {\n          return;\n        }\n\n        if (!this.isOpen()) {\n          try {\n            await this.initialize();\n            if (abortSignal && abortSignal.aborted) {\n              await this.abort();\n            }\n          } catch (err) {\n            if (this._onError === onError) {\n              onError(err);\n            }\n            return;\n          }\n        } else {\n          logger.verbose(\n            \"[%s] Receiver link already present, hence reusing it.\",\n            this._context.connectionId\n          );\n        }\n        // add credits\n        const existingCredits = this._receiver ? this._receiver.credit : 0;\n        const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;\n        const creditsToAdd = Math.max(\n          maximumCreditCount - (existingCredits + prcoessedEventCountToExclude),\n          0\n        );\n        this._addCredit(creditsToAdd);\n        return;\n      })\n      .catch((err) => {\n        // something really unexpected happened, so attempt to call user's error handler\n        if (this._onError === onError) {\n          onError(err);\n        }\n      });\n  }\n\n  private _addCredit(credit: number): void {\n    if (this._receiver) {\n      this._receiver.addCredit(credit);\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.receivers[this.name];\n    logger.verbose(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name\n    );\n  }\n\n  private async _useInternalQueue(\n    onMessage: OnMessage,\n    abortSignal?: AbortSignalLike\n  ): Promise<number> {\n    let processedMessagesCount = 0;\n    // allow the event loop to process any blocking code outside\n    // this code path before sending any events.\n    await delay(0);\n    this._usingInternalQueue = true;\n    while (this._internalQueue.length) {\n      if (!this._onMessage) {\n        break;\n      }\n\n      if (abortSignal && abortSignal.aborted) {\n        break;\n      }\n\n      // These will not be equal if clearHandlers and registerHandlers were called\n      // in the same tick of the event loop. If onMessage isn't the currently active\n      // handler, it should stop getting messages from the queue.\n      if (this._onMessage !== onMessage) {\n        break;\n      }\n      const eventData = this._internalQueue.splice(0, 1)[0];\n      processedMessagesCount++;\n      onMessage(eventData);\n      // allow the event loop to process any blocking code outside\n      // this code path before sending the next event.\n      await delay(0);\n    }\n    this._usingInternalQueue = false;\n    return processedMessagesCount;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   * @hidden\n   */\n  async initialize(): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        this.isConnecting = true;\n\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim();\n\n        const receiverOptions: CreateReceiverOptions = {\n          onClose: (context: EventContext) => this._onAmqpClose(context),\n          onError: (context: EventContext) => this._onAmqpError(context),\n          onMessage: (context: EventContext) => this._onAmqpMessage(context),\n          onSessionClose: (context: EventContext) => this._onAmqpSessionClose(context),\n          onSessionError: (context: EventContext) => this._onAmqpSessionError(context)\n        };\n        if (this.checkpoint > -1) {\n          receiverOptions.eventPosition = { sequenceNumber: this.checkpoint };\n        }\n        const options = this._createReceiverOptions(receiverOptions);\n\n        logger.verbose(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._receiver = await this._context.connection.createReceiver(options);\n        this.isConnecting = false;\n        logger.verbose(\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        // store the underlying link in a cache\n        this._context.receivers[this.name] = this;\n\n        await this._ensureTokenRenewal();\n      } else {\n        logger.verbose(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      const error = translate(err);\n      logger.warning(\n        \"[%s] An error occured while creating the receiver '%s': %s\",\n        this._context.connectionId,\n        this.name,\n        `${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(err);\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   * @hidden\n   */\n  private _createReceiverOptions(options: CreateReceiverOptions): RheaReceiverOptions {\n    if (options.newName) this.name = uuid();\n    const rcvrOptions: RheaReceiverOptions = {\n      name: this.name,\n      autoaccept: true,\n      source: {\n        address: this.address\n      },\n      credit_window: 0,\n      onMessage: options.onMessage || ((context: EventContext) => this._onAmqpMessage(context)),\n      onError: options.onError || ((context: EventContext) => this._onAmqpError(context)),\n      onClose: options.onClose || ((context: EventContext) => this._onAmqpClose(context)),\n      onSessionError:\n        options.onSessionError || ((context: EventContext) => this._onAmqpSessionError(context)),\n      onSessionClose:\n        options.onSessionClose || ((context: EventContext) => this._onAmqpSessionClose(context))\n    };\n\n    if (typeof this.ownerLevel === \"number\") {\n      rcvrOptions.properties = {\n        [Constants.attachEpoch]: types.wrap_long(this.ownerLevel)\n      };\n    }\n\n    if (this.options.trackLastEnqueuedEventProperties) {\n      rcvrOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n    }\n\n    const eventPosition = options.eventPosition || this.eventPosition;\n    if (eventPosition) {\n      // Set filter on the receiver if event position is specified.\n      const filterClause = getEventPositionFilter(eventPosition);\n      if (filterClause) {\n        (rcvrOptions.source as any).filter = {\n          \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004)\n        };\n      }\n    }\n    return rcvrOptions;\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds - The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @returns Promise<ReceivedEventData[]>.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while receiving a message.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    // store events across multiple retries\n    const receivedEvents: ReceivedEventData[] = [];\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      return new Promise(async (resolve, reject) => {\n        // if this consumer was closed,\n        // resolve the operation's promise with the events collected thus far in case\n        // the promise hasn't already been resolved.\n        if (this._isClosed || this._context.wasConnectionCloseCalled) {\n          return resolve(receivedEvents);\n        }\n\n        let timer: any;\n        const logOnAbort = (): void => {\n          const name = this.name;\n          const address = this.address;\n          const desc: string =\n            `[${this._context.connectionId}] The request operation on the Receiver \"${name}\" with ` +\n            `address \"${address}\" has been cancelled by the user.`;\n          // Cancellation is intentional so logging to 'info'.\n          logger.info(desc);\n        };\n\n        const rejectOnAbort = async (): Promise<void> => {\n          logOnAbort();\n          try {\n            await this.close();\n          } finally {\n            reject(new AbortError(\"The receive operation has been cancelled by the user.\"));\n          }\n        };\n\n        // operation has been cancelled, so exit immediately\n        if (abortSignal && abortSignal.aborted) {\n          return rejectOnAbort();\n        }\n\n        // updates the prefetch count so that the baseConsumer adds\n        // the correct number of credits to receive the same number of events.\n        const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);\n        if (prefetchCount === 0) {\n          return resolve(receivedEvents);\n        }\n\n        logger.verbose(\n          \"[%s] Receiver '%s', setting the prefetch count to %d.\",\n          this._context.connectionId,\n          this.name,\n          prefetchCount\n        );\n\n        const cleanUpBeforeReturn = (): void => {\n          this.clearHandlers();\n          clearTimeout(timer);\n        };\n\n        const onAbort = (): void => {\n          clearTimeout(timer);\n          rejectOnAbort();\n        };\n\n        this.registerHandlers(\n          (eventData) => {\n            receivedEvents.push(eventData);\n\n            // resolve the operation's promise after the requested\n            // number of events are received.\n            if (receivedEvents.length === maxMessageCount) {\n              logger.info(\n                \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                this._context.connectionId,\n                this.name,\n                receivedEvents.length,\n                maxWaitTimeInSeconds\n              );\n              cleanUpBeforeReturn();\n              resolve(receivedEvents);\n            }\n          },\n          (err) => {\n            // restore events to the front of the internal queue.\n            while (receivedEvents.length) {\n              this._internalQueue.unshift(receivedEvents.pop()!);\n            }\n            cleanUpBeforeReturn();\n            if (err.name === \"AbortError\") {\n              rejectOnAbort();\n            } else {\n              reject(err);\n            }\n          },\n          maxMessageCount - receivedEvents.length,\n          false,\n          abortSignal,\n          onAbort\n        );\n\n        const addTimeout = (): void => {\n          const msg = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n          logger.verbose(msg, this._context.connectionId, maxWaitTimeInSeconds, this.name);\n\n          // resolve the operation's promise after the requested\n          // max number of seconds have passed.\n          timer = setTimeout(() => {\n            logger.info(\n              \"[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.\",\n              this._context.connectionId,\n              this.name,\n              receivedEvents.length,\n              maxWaitTimeInSeconds\n            );\n            cleanUpBeforeReturn();\n            resolve(receivedEvents);\n          }, maxWaitTimeInSeconds * 1000);\n        };\n\n        addTimeout();\n        if (abortSignal && !abortSignal.aborted) {\n          abortSignal.addEventListener(\"abort\", onAbort);\n        }\n      });\n    };\n\n    const retryOptions = this.options.retryOptions || {};\n    const config: RetryConfig<ReceivedEventData[]> = {\n      connectionHost: this._context.config.host,\n      connectionId: this._context.connectionId,\n      operation: retrieveEvents,\n      operationType: RetryOperationType.receiveMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<ReceivedEventData[]>(config);\n  }\n}\n"]}