{"version":3,"file":"index.js","sources":["../src/util/typeGuards.ts","../src/log.ts","../src/util/runtimeInfo.ts","../src/util/constants.ts","../src/util/connectionStringUtils.ts","../src/eventhubSharedKeyCredential.ts","../src/linkEntity.ts","../src/util/retries.ts","../src/util/error.ts","../src/util/operationOptions.ts","../src/managementClient.ts","../src/util/parseEndpoint.ts","../src/eventhubConnectionConfig.ts","../src/connectionContext.ts","../src/inMemoryCheckpointStore.ts","../src/models/public.ts","../src/eventData.ts","../src/eventPosition.ts","../src/dataTransformer.ts","../src/eventHubReceiver.ts","../src/diagnostics/instrumentEventData.ts","../src/partitionPump.ts","../src/pumpManager.ts","../src/partitionProcessor.ts","../src/util/delayWithoutThrow.ts","../src/eventProcessor.ts","../src/impl/partitionGate.ts","../src/loadBalancerStrategies/unbalancedStrategy.ts","../src/loadBalancerStrategies/loadBalancingStrategy.ts","../src/loadBalancerStrategies/greedyStrategy.ts","../src/loadBalancerStrategies/balancedStrategy.ts","../src/eventHubConsumerClient.ts","../src/diagnostics/messageSpan.ts","../src/eventDataBatch.ts","../src/eventHubSender.ts","../src/eventHubProducerClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Helper TypeGuard that checks if something is defined or not.\n * @param thing - Anything\n * @internal\n */\nexport function isDefined<T>(thing: T | undefined | null): thing is T {\n  return typeof thing !== \"undefined\" && thing !== null;\n}\n\n/**\n * Helper TypeGuard that checks if the input is an object with the specified properties.\n * @param thing - Anything.\n * @param properties - The name of the properties that should appear in the object.\n * @internal\n */\nexport function isObjectWithProperties<Thing extends unknown, PropertyName extends string>(\n  thing: Thing,\n  properties: PropertyName[]\n): thing is Thing & Record<PropertyName, unknown> {\n  if (!isDefined(thing) || typeof thing !== \"object\") {\n    return false;\n  }\n\n  for (const property of properties) {\n    if (!objectHasProperty(thing, property)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Helper TypeGuard that checks if the input is an object with the specified property.\n * @param thing - Any object.\n * @param property - The name of the property that should appear in the object.\n * @internal\n */\nexport function objectHasProperty<Thing extends unknown, PropertyName extends string>(\n  thing: Thing,\n  property: PropertyName\n): thing is Thing & Record<PropertyName, unknown> {\n  if (!(property in thing)) {\n    return false;\n  }\n\n  return true;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\nimport { isObjectWithProperties } from \"./util/typeGuards\";\n\n/**\n * The @azure/logger configuration for this package.\n * This will output logs using the `azure:event-hubs` namespace prefix.\n */\nexport const logger = createClientLogger(\"event-hubs\");\n\n/**\n * Logs the error's stack trace to \"verbose\" if a stack trace is available.\n * @param error - Error containing a stack trace.\n * @hidden\n */\nexport function logErrorStackTrace(error: unknown): void {\n  if (isObjectWithProperties(error, [\"stack\"]) && error.stack) {\n    logger.verbose(error.stack);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as os from \"os\";\n\n/**\n * Returns information about the platform this function is being run on.\n * @internal\n */\nexport function getRuntimeInfo(): string {\n  return `NODE-VERSION ${process.version}; ${os.type()} ${os.release()}`;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @hidden\n */\nexport const packageJsonInfo = {\n  name: \"@azure/event-hubs\",\n  version: \"5.4.0\"\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseConnectionString } from \"@azure/core-amqp\";\n\n/**\n * The set of properties that comprise an Event Hub connection string.\n */\nexport interface EventHubConnectionStringProperties {\n  /**\n   * The fully qualified Event Hub namespace extracted from the \"Endpoint\" in the\n   * connection string. This is likely to be similar to \"{yournamespace}.servicebus.windows.net\".\n   * This is typically used to construct the EventHub{Producer|Consumer}Client.\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The value for \"Endpoint\" in the connection string.\n   */\n  endpoint: string;\n  /**\n   * The value for \"EntityPath\" in the connection string which would be the name of the event hub instance associated with the connection string.\n   * Connection string from a Shared Access Policy created at the namespace level\n   * will not have the EntityPath in it.\n   */\n  eventHubName?: string;\n  /**\n   * The value for \"SharedAccessKey\" in the connection string. This along with the \"SharedAccessKeyName\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKey?: string;\n  /**\n   * The value for \"SharedAccessKeyName\" in the connection string. This along with the \"SharedAccessKey\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKeyName?: string;\n  /**\n   * The value for \"SharedAccessSignature\" in the connection string. This is typically not present in the\n   * connection string generated for a Shared Access Policy. It is instead generated by the\n   * user and appended to the connection string for ease of use.\n   */\n  sharedAccessSignature?: string;\n}\n\n/**\n * Parses given connection string into the different properties applicable to Azure Event Hubs.\n * The properties are useful to then construct an EventHub{Producer|Consumer}Client.\n * @param connectionString - The connection string associated with the Shared Access Policy created\n * for the Event Hubs namespace.\n */\nexport function parseEventHubConnectionString(\n  connectionString: string\n): Readonly<EventHubConnectionStringProperties> {\n  const parsedResult = parseConnectionString<{\n    Endpoint: string;\n    EntityPath?: string;\n    SharedAccessSignature?: string;\n    SharedAccessKey?: string;\n    SharedAccessKeyName?: string;\n  }>(connectionString);\n\n  validateProperties(\n    parsedResult.Endpoint,\n    parsedResult.SharedAccessSignature,\n    parsedResult.SharedAccessKey,\n    parsedResult.SharedAccessKeyName\n  );\n\n  const output: EventHubConnectionStringProperties = {\n    fullyQualifiedNamespace: (parsedResult.Endpoint.match(\".*://([^/]*)\") || [])[1],\n    endpoint: parsedResult.Endpoint\n  };\n\n  if (parsedResult.EntityPath) {\n    output.eventHubName = parsedResult.EntityPath;\n  }\n\n  if (parsedResult.SharedAccessSignature) {\n    output.sharedAccessSignature = parsedResult.SharedAccessSignature;\n  }\n\n  if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    output.sharedAccessKey = parsedResult.SharedAccessKey;\n    output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;\n  }\n\n  return output;\n}\n\n/**\n * @internal\n */\nfunction validateProperties(\n  endpoint?: string,\n  sharedAccessSignature?: string,\n  sharedAccessKey?: string,\n  sharedAccessKeyName?: string\n): void {\n  if (!endpoint) {\n    throw new Error(\"Connection string should have an Endpoint key.\");\n  }\n\n  if (sharedAccessSignature) {\n    if (sharedAccessKey || sharedAccessKeyName) {\n      throw new Error(\n        \"Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.\"\n      );\n    }\n  } else if (sharedAccessKey && !sharedAccessKeyName) {\n    throw new Error(\"Connection string with SharedAccessKey should have SharedAccessKeyName.\");\n  } else if (!sharedAccessKey && sharedAccessKeyName) {\n    throw new Error(\n      \"Connection string with SharedAccessKeyName should have SharedAccessKey as well.\"\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseEventHubConnectionString } from \"./util/connectionStringUtils\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { Buffer } from \"buffer\";\nimport isBuffer from \"is-buffer\";\nimport jssha from \"jssha\";\n\n/**\n * Defines the SharedKeyCredential .\n */\nexport class SharedKeyCredential {\n  /**\n   * The name of the EventHub/ServiceBus key.\n   */\n  keyName: string;\n\n  /**\n   * The secret value associated with the above EventHub/ServiceBus key.\n   */\n  key: string;\n\n  /**\n   * Initializes a new instance of SharedKeyCredential\n   * @param keyName - The name of the EventHub/ServiceBus key.\n   * @param key - The secret value associated with the above EventHub/ServiceBus key\n   */\n  constructor(keyName: string, key: string) {\n    this.keyName = keyName;\n    this.key = key;\n  }\n\n  /**\n   * Gets the sas token for the specified audience\n   * @param audience - The audience for which the token is desired.\n   */\n  getToken(audience: string): AccessToken {\n    return this._createToken(Math.floor(Date.now() / 1000) + 3600, audience);\n  }\n\n  /**\n   * Creates the sas token based on the provided information\n   * @param expiry - The time period in unix time after which the token will expire.\n   * @param audience - The audience for which the token is desired.\n   * @param hashInput - The input to be provided to hmac to create the hash.\n   */\n  protected _createToken(\n    expiry: number,\n    audience: string,\n    hashInput?: string | Buffer\n  ): AccessToken {\n    audience = encodeURIComponent(audience);\n    const keyName = encodeURIComponent(this.keyName);\n    const stringToSign = audience + \"\\n\" + expiry;\n    hashInput = hashInput || this.key;\n    let shaObj: any;\n    if (isBuffer(hashInput)) {\n      shaObj = new jssha(\"SHA-256\", \"ARRAYBUFFER\");\n      shaObj.setHMACKey(hashInput, \"ARRAYBUFFER\");\n      shaObj.update(Buffer.from(stringToSign));\n    } else {\n      shaObj = new jssha(\"SHA-256\", \"TEXT\");\n      shaObj.setHMACKey(hashInput, \"TEXT\");\n      shaObj.update(stringToSign);\n    }\n    const sig = encodeURIComponent(shaObj.getHMAC(\"B64\"));\n    return {\n      token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,\n      expiresOnTimestamp: expiry\n    };\n  }\n\n  /**\n   * Creates a token provider from the EventHub/ServiceBus connection string;\n   * @param connectionString - The EventHub/ServiceBus connection string\n   */\n  static fromConnectionString(connectionString: string): SharedKeyCredential {\n    const parsed = parseEventHubConnectionString(connectionString);\n\n    if (parsed.sharedAccessSignature == null) {\n      return new SharedKeyCredential(parsed.sharedAccessKeyName!, parsed.sharedAccessKey!);\n    } else {\n      return new SharedAccessSignatureCredential(parsed.sharedAccessSignature);\n    }\n  }\n}\n\n/**\n * A credential that takes a SharedAccessSignature:\n * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`\n *\n * @internal\n */\nexport class SharedAccessSignatureCredential extends SharedKeyCredential {\n  private _accessToken: AccessToken;\n\n  /**\n   * @param sharedAccessSignature - A shared access signature of the form\n   * `SharedAccessSignature sr=<resource>&sig=<signature>&se=<expiry>&skn=<keyname>`\n   */\n  constructor(sharedAccessSignature: string) {\n    super(\"\", \"\");\n\n    this._accessToken = {\n      token: sharedAccessSignature,\n      expiresOnTimestamp: 0\n    };\n  }\n\n  /**\n   * Retrieve a valid token for authenticaton.\n   *\n   * @param _audience - Not applicable in SharedAccessSignatureCredential as the token is not re-generated at every invocation of the method\n   */\n  getToken(_audience: string): AccessToken {\n    return this._accessToken;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { Constants, TokenType, defaultLock } from \"@azure/core-amqp\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { AwaitableSender, Receiver } from \"rhea-promise\";\nimport { logger } from \"./log\";\nimport { SharedKeyCredential } from \"../src/eventhubSharedKeyCredential\";\n\n/**\n * @hidden\n */\nexport interface LinkEntityOptions {\n  /**\n   * The unique name for the entity. If not provided then a guid will be\n   * assigned.\n   */\n  name?: string;\n  /**\n   * The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * The link entity address in one of the following forms:\n   */\n  address?: string;\n  /**\n   * The link entity token audience in one of the following forms:\n   */\n  audience?: string;\n}\n\n/**\n * Describes the base class for entities like EventHub Sender, Receiver and Management link.\n * @internal\n */\nexport class LinkEntity {\n  /**\n   * The unique name for the entity (mostly a guid).\n   */\n  name: string;\n  /**\n   * The link entity address in one of the following forms:\n   *\n   * **Sender**\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * -`\"$management\"`.\n   */\n  address: string;\n  /**\n   * The link entity token audience in one of the following forms:\n   *\n   * **Sender**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`.\n   *\n   * **Receiver**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`.\n   *\n   * **ManagementClient**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management\"`.\n   */\n  audience: string;\n  /**\n   * The partitionId associated with the link entity.\n   */\n  partitionId?: string;\n  /**\n   * Indicates whether the link is in the process of connecting\n   * (establishing) itself. Default value: `false`.\n   */\n  isConnecting: boolean = false;\n  /**\n   * Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   */\n  protected _context: ConnectionContext;\n  /**\n   * The token renewal timer that keeps track of when\n   * the Link Entity is due for token renewal.\n   */\n  protected _tokenRenewalTimer?: NodeJS.Timer;\n  /**\n   * Indicates token timeout in milliseconds\n   */\n  protected _tokenTimeoutInMs?: number;\n  /**\n   * Creates a new LinkEntity instance.\n   * @hidden\n   * @param context - The connection context.\n   * @param options - Options that can be provided while creating the LinkEntity.\n   */\n  constructor(context: ConnectionContext, options?: LinkEntityOptions) {\n    if (!options) options = {};\n    this._context = context;\n    this.address = options.address || \"\";\n    this.audience = options.audience || \"\";\n    this.name = `${options.name}-${uuid()}`;\n    this.partitionId = options.partitionId;\n  }\n\n  /**\n   * Negotiates cbs claim for the LinkEntity.\n   * @hidden\n   * @param setTokenRenewal - Set the token renewal timer. Default false.\n   * @returns Promise<void>\n   */\n  protected async _negotiateClaim(setTokenRenewal?: boolean): Promise<void> {\n    // Acquire the lock and establish a cbs session if it does not exist on the connection.\n    // Although node.js is single threaded, we need a locking mechanism to ensure that a\n    // race condition does not happen while creating a shared resource (in this case the\n    // cbs session, since we want to have exactly 1 cbs session per connection).\n    logger.verbose(\n      \"[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: \" +\n        \"'%s' with address: '%s'.\",\n      this._context.connectionId,\n      this._context.cbsSession.cbsLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.cbsSession.cbsLock, () => {\n      return this._context.cbsSession.init();\n    });\n    let tokenObject: AccessToken;\n    let tokenType: TokenType;\n    if (this._context.tokenCredential instanceof SharedKeyCredential) {\n      tokenObject = this._context.tokenCredential.getToken(this.audience);\n      tokenType = TokenType.CbsTokenTypeSas;\n\n      // expiresOnTimestamp can be 0 if the token is not meant to be renewed\n      // (ie, SharedAccessSignatureCredential)\n      if (tokenObject.expiresOnTimestamp > 0) {\n        // renew sas token in every 45 minutess\n        this._tokenTimeoutInMs = (3600 - 900) * 1000;\n      }\n    } else {\n      const aadToken = await this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n      if (!aadToken) {\n        throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n      }\n      tokenObject = aadToken;\n      tokenType = TokenType.CbsTokenTypeJwt;\n      this._tokenTimeoutInMs = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;\n    }\n\n    logger.verbose(\n      \"[%s] %s: calling negotiateClaim for audience '%s'.\",\n      this._context.connectionId,\n      this._type,\n      this.audience\n    );\n    // Acquire the lock to negotiate the CBS claim.\n    logger.verbose(\n      \"[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.\",\n      this._context.connectionId,\n      this._context.negotiateClaimLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.negotiateClaimLock, () => {\n      return this._context.cbsSession.negotiateClaim(this.audience, tokenObject.token, tokenType);\n    });\n    logger.verbose(\n      \"[%s] Negotiated claim for %s '%s' with with address: %s\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address\n    );\n    if (setTokenRenewal) {\n      await this._ensureTokenRenewal();\n    }\n  }\n\n  /**\n   * Ensures that the token is renewed within the predefined renewal margin.\n   * @hidden\n   */\n  protected async _ensureTokenRenewal(): Promise<void> {\n    if (!this._tokenTimeoutInMs) {\n      return;\n    }\n    // Clear the existing token renewal timer.\n    // This scenario can happen if the connection goes down and is brought back up\n    // before the `nextRenewalTimeout` was reached.\n    if (this._tokenRenewalTimer) {\n      clearTimeout(this._tokenRenewalTimer);\n    }\n    this._tokenRenewalTimer = setTimeout(async () => {\n      try {\n        await this._negotiateClaim(true);\n      } catch (err) {\n        logger.verbose(\n          \"[%s] %s '%s' with address %s, an error occurred while renewing the token: %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }, this._tokenTimeoutInMs);\n    logger.verbose(\n      \"[%s] %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).\",\n      this._context.connectionId,\n      this._type,\n      this.name,\n      this.address,\n      this._tokenTimeoutInMs,\n      new Date(Date.now() + this._tokenTimeoutInMs).toString()\n    );\n  }\n\n  /**\n   * Closes the Sender|Receiver link and it's underlying session and also removes it from the\n   * internal map.\n   * @hidden\n   * @param link - The Sender or Receiver link that needs to be closed and\n   * removed.\n   */\n  protected async _closeLink(link?: AwaitableSender | Receiver): Promise<void> {\n    clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n    if (link) {\n      try {\n        // Closing the link and its underlying session if the link is open. This should also\n        // remove them from the internal map.\n        await link.close();\n        logger.verbose(\n          \"[%s] %s '%s' with address '%s' closed.\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address\n        );\n      } catch (err) {\n        logger.verbose(\n          \"[%s] An error occurred while closing the %s '%s' with address '%s': %O\",\n          this._context.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }\n  }\n\n  /**\n   * Provides the current type of the LinkEntity.\n   * @returns The entity type.\n   */\n  private get _type(): string {\n    let result = \"LinkEntity\";\n    if ((this as any).constructor && (this as any).constructor.name) {\n      result = (this as any).constructor.name;\n    }\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, RetryOptions } from \"@azure/core-amqp\";\nimport { isDefined } from \"./typeGuards\";\n\n/**\n * @internal\n */\nexport function getRetryAttemptTimeoutInMs(retryOptions: RetryOptions | undefined): number {\n  const timeoutInMs =\n    !isDefined(retryOptions) ||\n    typeof retryOptions.timeoutInMs !== \"number\" ||\n    !isFinite(retryOptions.timeoutInMs) ||\n    retryOptions.timeoutInMs < Constants.defaultOperationTimeoutInMs\n      ? Constants.defaultOperationTimeoutInMs\n      : retryOptions.timeoutInMs;\n  return timeoutInMs;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"../log\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { isDefined } from \"./typeGuards\";\n\n/**\n * @internal\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context - The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] ${error.name}: ${error.message}`);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param methodName - Name of the method that was passed the parameter\n * @param parameterName - Name of the parameter to check\n * @param parameterValue - Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  methodName: string,\n  parameterName: string,\n  parameterValue: unknown\n): void {\n  if (!isDefined(parameterValue)) {\n    const error = new TypeError(\n      `${methodName} called without required argument \"${parameterName}\"`\n    );\n    logger.warning(`[${connectionId}] ${error.name}: ${error.message}`);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { Span, SpanContext } from \"@opentelemetry/api\";\nimport { OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * Options for configuring tracing and the abortSignal.\n */\n// NOTE: This class is intended to mirror the relevant fields and structure from\n// @azure/core-http OperationOptions\nexport interface OperationOptions {\n  /**\n   * The signal which can be used to abort requests.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Options for configuring tracing.\n   */\n  tracingOptions?: OperationTracingOptions;\n}\n\n/**\n * @internal\n */\nexport function getParentSpan(\n  options?: OperationTracingOptions\n): Span | SpanContext | null | undefined {\n  return options?.spanOptions?.parent;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport {\n  Constants,\n  RequestResponseLink,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  SendRequestOptions,\n  defaultLock,\n  retry,\n  translate\n} from \"@azure/core-amqp\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport {\n  EventContext,\n  Message,\n  ReceiverEvents,\n  ReceiverOptions,\n  SenderEvents,\n  SenderOptions,\n  generate_uuid\n} from \"rhea-promise\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { OperationNames } from \"./models/private\";\nimport { Span, SpanContext, SpanKind, CanonicalCode } from \"@opentelemetry/api\";\nimport { getParentSpan, OperationOptions } from \"./util/operationOptions\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { SharedKeyCredential } from \"../src/eventhubSharedKeyCredential\";\n\n/**\n * Describes the runtime information of an Event Hub.\n */\nexport interface EventHubProperties {\n  /**\n   * The name of the event hub.\n   */\n  name: string;\n  /**\n   * The date and time the hub was created in UTC.\n   */\n  createdOn: Date;\n  /**\n   * The slice of string partition identifiers.\n   */\n  partitionIds: string[];\n}\n\n/**\n * Describes the runtime information of an EventHub Partition.\n */\nexport interface PartitionProperties {\n  /**\n   * The name of the Event Hub.\n   */\n  eventHubName: string;\n  /**\n   * Identifier of the partition within the Event Hub.\n   */\n  partitionId: string;\n  /**\n   * The starting sequence number of the partition's message log.\n   */\n  beginningSequenceNumber: number;\n  /**\n   * The last sequence number of the partition's message log.\n   */\n  lastEnqueuedSequenceNumber: number;\n  /**\n   * The offset of the last enqueued message in the partition's message log.\n   */\n  lastEnqueuedOffset: number;\n  /**\n   * The time of the last enqueued message in the partition's message log in UTC.\n   */\n  lastEnqueuedOnUtc: Date;\n  /**\n   * Indicates whether the partition is empty.\n   */\n  isEmpty: boolean;\n}\n\n/**\n * @internal\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @internal\n * Descibes the EventHubs Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient extends LinkEntity {\n  readonly managementLock: string = `${Constants.managementRequestKey}-${uuid()}`;\n  /**\n   * The name/path of the entity (hub name) for which the management\n   * request needs to be made.\n   */\n  entityPath: string;\n  /**\n   * The reply to Guid for the management client.\n   */\n  replyTo: string = uuid();\n  /**\n   * $management sender, receiver on the same session.\n   */\n  private _mgmtReqResLink?: RequestResponseLink;\n\n  /**\n   * Instantiates the management client.\n   * @hidden\n   * @param context - The connection context.\n   * @param address - The address for the management endpoint. For IotHub it will be\n   * `/messages/events/$management`.\n   */\n  constructor(context: ConnectionContext, options?: ManagementClientOptions) {\n    super(context, {\n      address: options && options.address ? options.address : Constants.management,\n      audience:\n        options && options.audience ? options.audience : context.config.getManagementAudience()\n    });\n    this._context = context;\n    this.entityPath = context.config.entityPath as string;\n  }\n\n  /**\n   * Gets the security token for the management application properties.\n   * @internal\n   */\n  async getSecurityToken(): Promise<AccessToken | null> {\n    if (this._context.tokenCredential instanceof SharedKeyCredential) {\n      // the security_token has the $management address removed from the end of the audience\n      // expected audience: sb://fully.qualified.namespace/event-hub-name/$management\n      const audienceParts = this.audience.split(\"/\");\n      // for management links, address should be '$management'\n      if (audienceParts[audienceParts.length - 1] === this.address) {\n        audienceParts.pop();\n      }\n      const audience = audienceParts.join(\"/\");\n      return this._context.tokenCredential.getToken(audience);\n    }\n\n    // aad credentials use the aad scope\n    return this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n  }\n\n  /**\n   * Provides the eventhub runtime information.\n   * @hidden\n   */\n  async getEventHubProperties(\n    options: OperationOptions & { retryOptions?: RetryOptions } = {}\n  ): Promise<EventHubProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    const clientSpan = this._createClientSpan(\n      \"getEventHubProperties\",\n      getParentSpan(options.tracingOptions)\n    );\n    try {\n      const securityToken = await this.getSecurityToken();\n      const request: Message = {\n        body: Buffer.from(JSON.stringify([])),\n        message_id: uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.readOperation,\n          name: this.entityPath as string,\n          type: `${Constants.vendorString}:${Constants.eventHub}`,\n          security_token: securityToken?.token\n        }\n      };\n\n      const info: any = await this._makeManagementRequest(request, {\n        ...options,\n        requestName: \"getHubRuntimeInformation\"\n      });\n      const runtimeInfo: EventHubProperties = {\n        name: info.name,\n        createdOn: new Date(info.created_at),\n        partitionIds: info.partition_ids\n      };\n      logger.verbose(\"[%s] The hub runtime info is: %O\", this._context.connectionId, runtimeInfo);\n\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n      return runtimeInfo;\n    } catch (error) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: error.message\n      });\n      logger.warning(\n        `An error occurred while getting the hub runtime information: ${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(error);\n      throw error;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @hidden\n   * @param partitionId - Partition ID for which partition information is required.\n   */\n  async getPartitionProperties(\n    partitionId: string,\n    options: OperationOptions & { retryOptions?: RetryOptions } = {}\n  ): Promise<PartitionProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"getPartitionProperties\",\n      \"partitionId\",\n      partitionId\n    );\n    partitionId = String(partitionId);\n\n    const clientSpan = this._createClientSpan(\n      \"getPartitionProperties\",\n      getParentSpan(options.tracingOptions)\n    );\n\n    try {\n      const securityToken = await this.getSecurityToken();\n      const request: Message = {\n        body: Buffer.from(JSON.stringify([])),\n        message_id: uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.readOperation,\n          name: this.entityPath as string,\n          type: `${Constants.vendorString}:${Constants.partition}`,\n          partition: `${partitionId}`,\n          security_token: securityToken?.token\n        }\n      };\n\n      const info: any = await this._makeManagementRequest(request, {\n        ...options,\n        requestName: \"getPartitionInformation\"\n      });\n\n      const partitionInfo: PartitionProperties = {\n        beginningSequenceNumber: info.begin_sequence_number,\n        eventHubName: info.name,\n        lastEnqueuedOffset: info.last_enqueued_offset,\n        lastEnqueuedOnUtc: new Date(info.last_enqueued_time_utc),\n        lastEnqueuedSequenceNumber: info.last_enqueued_sequence_number,\n        partitionId: info.partition,\n        isEmpty: info.is_partition_empty\n      };\n      logger.verbose(\"[%s] The partition info is: %O.\", this._context.connectionId, partitionInfo);\n\n      clientSpan.setStatus({ code: CanonicalCode.OK });\n\n      return partitionInfo;\n    } catch (error) {\n      clientSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: error.message\n      });\n      logger.warning(\n        `An error occurred while getting the partition information: ${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(error);\n      throw error;\n    } finally {\n      clientSpan.end();\n    }\n  }\n\n  /**\n   * Closes the AMQP management session to the Event Hub for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @hidden\n   */\n  async close(): Promise<void> {\n    try {\n      // Always clear the timeout, as the isOpen check may report\n      // false without ever having cleared the timeout otherwise.\n      clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n      if (this._isMgmtRequestResponseLinkOpen()) {\n        const mgmtLink = this._mgmtReqResLink;\n        this._mgmtReqResLink = undefined;\n        await mgmtLink!.close();\n        logger.info(\"Successfully closed the management session.\");\n      }\n    } catch (err) {\n      const msg = `An error occurred while closing the management session: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw new Error(msg);\n    }\n  }\n\n  private async _init(): Promise<void> {\n    try {\n      if (!this._isMgmtRequestResponseLinkOpen()) {\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim();\n        const rxopt: ReceiverOptions = {\n          source: { address: this.address },\n          name: this.replyTo,\n          target: { address: this.replyTo },\n          onSessionError: (context: EventContext) => {\n            const id = context.connection.options.id;\n            const ehError = translate(context.session!.error!);\n            logger.verbose(\n              \"[%s] An error occurred on the session for request/response links for \" +\n                \"$management: %O\",\n              id,\n              ehError\n            );\n          }\n        };\n        const sropt: SenderOptions = {\n          target: { address: this.address }\n        };\n        logger.verbose(\n          \"[%s] Creating sender/receiver links on a session for $management endpoint with \" +\n            \"srOpts: %o, receiverOpts: %O.\",\n          this._context.connectionId,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink = await RequestResponseLink.create(\n          this._context.connection,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink.sender.on(SenderEvents.senderError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.sender!.error!);\n          logger.verbose(\"[%s] An error occurred on the $management sender link.. %O\", id, ehError);\n        });\n        this._mgmtReqResLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.receiver!.error!);\n          logger.verbose(\n            \"[%s] An error occurred on the $management receiver link.. %O\",\n            id,\n            ehError\n          );\n        });\n        logger.verbose(\n          \"[%s] Created sender '%s' and receiver '%s' links for $management endpoint.\",\n          this._context.connectionId,\n          this._mgmtReqResLink.sender.name,\n          this._mgmtReqResLink.receiver.name\n        );\n        await this._ensureTokenRenewal();\n      }\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        `[${this._context.connectionId}] An error occured while establishing the $management links: ${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Helper method to make the management request\n   * @param request - The AMQP message to send\n   * @param options - The options to use when sending a request over a $management link\n   */\n  private async _makeManagementRequest(\n    request: Message,\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n      requestName?: string;\n    } = {}\n  ): Promise<any> {\n    const retryOptions = options.retryOptions || {};\n    try {\n      const abortSignal: AbortSignalLike | undefined = options && options.abortSignal;\n\n      const sendOperationPromise = (): Promise<Message> =>\n        new Promise<Message>(async (resolve, reject) => {\n          let count = 0;\n\n          const retryTimeoutInMs = getRetryAttemptTimeoutInMs(options.retryOptions);\n          let timeTakenByInit = 0;\n\n          const rejectOnAbort = (): void => {\n            const requestName = options.requestName;\n            const desc: string =\n              `[${this._context.connectionId}] The request \"${requestName}\" ` +\n              `to has been cancelled by the user.`;\n            // Cancellation is user-intended behavior, so log to info instead of warning.\n            logger.info(desc);\n            const error = new AbortError(\n              `The ${requestName ? requestName + \" \" : \"\"}operation has been cancelled by the user.`\n            );\n\n            reject(error);\n          };\n\n          if (abortSignal) {\n            if (abortSignal.aborted) {\n              return rejectOnAbort();\n            }\n          }\n\n          if (!this._isMgmtRequestResponseLinkOpen()) {\n            logger.verbose(\n              \"[%s] Acquiring lock to get the management req res link.\",\n              this._context.connectionId\n            );\n\n            const initOperationStartTime = Date.now();\n\n            const actionAfterTimeout = (): void => {\n              const desc: string = `The request with message_id \"${request.message_id}\" timed out. Please try again later.`;\n              const e: Error = {\n                name: \"OperationTimeoutError\",\n                message: desc\n              };\n\n              return reject(translate(e));\n            };\n\n            const waitTimer = setTimeout(actionAfterTimeout, retryTimeoutInMs);\n\n            try {\n              await defaultLock.acquire(this.managementLock, () => {\n                return this._init();\n              });\n            } catch (err) {\n              return reject(translate(err));\n            } finally {\n              clearTimeout(waitTimer);\n            }\n            timeTakenByInit = Date.now() - initOperationStartTime;\n          }\n\n          const remainingOperationTimeoutInMs = retryTimeoutInMs - timeTakenByInit;\n\n          const sendRequestOptions: SendRequestOptions = {\n            abortSignal: options.abortSignal,\n            requestName: options.requestName,\n            timeoutInMs: remainingOperationTimeoutInMs\n          };\n\n          count++;\n          if (count !== 1) {\n            // Generate a new message_id every time after the first attempt\n            request.message_id = generate_uuid();\n          } else if (!request.message_id) {\n            // Set the message_id in the first attempt only if it is not set\n            request.message_id = generate_uuid();\n          }\n\n          try {\n            const result = await this._mgmtReqResLink!.sendRequest(request, sendRequestOptions);\n            resolve(result);\n          } catch (err) {\n            const translatedError = translate(err);\n            logger.warning(\n              \"[%s] An error occurred during send on management request-response link with address '%s': %s\",\n              this._context.connectionId,\n              this.address,\n              `${translatedError?.name}: ${translatedError?.message}`\n            );\n            logErrorStackTrace(translatedError);\n            reject(translatedError);\n          }\n        });\n\n      const config: RetryConfig<Message> = {\n        operation: sendOperationPromise,\n        connectionId: this._context.connectionId,\n        operationType: RetryOperationType.management,\n        abortSignal: abortSignal,\n        retryOptions: retryOptions\n      };\n      return (await retry<Message>(config)).body;\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        `An error occurred while making the request to $management endpoint: ${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  private _isMgmtRequestResponseLinkOpen(): boolean {\n    return this._mgmtReqResLink! && this._mgmtReqResLink!.isOpen();\n  }\n\n  private _createClientSpan(\n    operationName: OperationNames,\n    parentSpan?: Span | SpanContext | null,\n    internal: boolean = false\n  ): Span {\n    const tracer = getTracer();\n    const span = tracer.startSpan(`Azure.EventHubs.${operationName}`, {\n      kind: internal ? SpanKind.INTERNAL : SpanKind.CLIENT,\n      parent: parentSpan\n    });\n\n    span.setAttribute(\"az.namespace\", \"Microsoft.EventHub\");\n    span.setAttribute(\"message_bus.destination\", this._context.config.entityPath);\n    span.setAttribute(\"peer.address\", this._context.config.host);\n\n    return span;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Parses the host, hostname, and port from an endpoint.\n * @param endpoint - And endpoint to parse.\n * @internal\n */\nexport function parseEndpoint(endpoint: string): { host: string; hostname: string; port?: string } {\n  const hostMatch = endpoint.match(/.*:\\/\\/([^/]*)/);\n  if (!hostMatch) {\n    throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);\n  }\n\n  const [, host] = hostMatch;\n  const [hostname, port] = host.split(\":\");\n\n  return { host, hostname, port };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\n\nimport { ConnectionConfig } from \"@azure/core-amqp\";\nimport { parseEndpoint } from \"./util/parseEndpoint\";\n\n/**\n * Describes the connection config object that is created after parsing an EventHub connection\n * string. It also provides some convenience methods for getting the address and audience for\n * different entities.\n * @internal\n */\nexport interface EventHubConnectionConfig extends ConnectionConfig {\n  /**\n   * The name/path of the entity (event hub name) to which the\n   * connection needs to happen.\n   */\n  entityPath: string;\n  /**\n   * Provides the EventHub Sender address in one of the following forms based on the input:\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub to which messages will be sent.\n   */\n  getSenderAddress(partitionId?: string | number): string;\n  /**\n   * Provides the EventHub Sender audience in one of the following forms based on the input:\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub to which messages will be sent.\n   */\n  getSenderAudience(partitionId?: string | number): string;\n  /**\n   * Provides the EventHub Receiver address:\n   * - `\"<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub from which messages will be received.\n   * @param consumergroup - The consumergoup in the EventHub from which the messages will\n   * be received. Default: `$default`.\n   */\n  getReceiverAddress(partitionId: string | number, consumergroup?: string): string;\n  /**\n   * Provides the EventHub Receiver audience.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub from which messages will be received.\n   * @param consumergroup - The consumergoup in the EventHub from which the messages will\n   * be received. Default: `$default`.\n   */\n  getReceiverAudience(partitionId: string | number, consumergroup?: string): string;\n  /**\n   * Provides the EventHub Management address.\n   * - `\"<hub-name>/$management\"`\n   */\n  getManagementAddress(): string;\n  /**\n   * Provides the EventHub Management audience.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<hub-name>/$management\"`\n   */\n  getManagementAudience(): string;\n}\n\n/**\n * Describes the connection config object that is created after parsing an EventHub connection\n * string. It also provides some convenience methods for getting the address and audience for\n * different entities.\n * @internal\n */\nexport const EventHubConnectionConfig = {\n  /**\n   * Creates the connection config.\n   * @param connectionString - The connection string for a given service like\n   * EventHub/ServiceBus.\n   * @param path - The name/path of the entity (hub name) to which the\n   * connection needs to happen. This will override the EntityPath in the connectionString\n   * if present.\n   * @returns EventHubConnectionConfig\n   */\n  create(connectionString: string, path?: string): EventHubConnectionConfig {\n    const config = ConnectionConfig.create(connectionString, path);\n    if (!config.entityPath) {\n      throw new TypeError(\n        `Either provide \"path\" or the \"connectionString\": \"${connectionString}\", ` +\n          `must contain EntityPath=\"<path-to-the-entity>\".`\n      );\n    }\n    return EventHubConnectionConfig.createFromConnectionConfig(config);\n  },\n\n  /**\n   * Creates an EventHubConnectionConfig from the provided base ConnectionConfig.\n   * @param config - The base connection config from which the EventHubConnectionConfig needs to be\n   * created.\n   * @returns EventHubConnectionConfig\n   */\n  createFromConnectionConfig(config: ConnectionConfig): EventHubConnectionConfig {\n    ConnectionConfig.validate(config, { isEntityPathRequired: true });\n\n    (config as EventHubConnectionConfig).getManagementAudience = () => {\n      return `${config.endpoint}${config.entityPath}/$management`;\n    };\n    (config as EventHubConnectionConfig).getManagementAddress = () => {\n      return `${config.entityPath}/$management`;\n    };\n\n    (config as EventHubConnectionConfig).getSenderAudience = (partitionId?: string | number) => {\n      if (partitionId != undefined) {\n        return `${config.endpoint}${config.entityPath}/Partitions/${partitionId}`;\n      } else {\n        return `${config.endpoint}${config.entityPath}`;\n      }\n    };\n\n    (config as EventHubConnectionConfig).getSenderAddress = (partitionId?: string | number) => {\n      if (partitionId != undefined) {\n        return `${config.entityPath}/Partitions/${partitionId}`;\n      } else {\n        return `${config.entityPath}`;\n      }\n    };\n\n    (config as EventHubConnectionConfig).getReceiverAudience = (\n      partitionId: string | number,\n      consumergroup?: string\n    ) => {\n      if (!consumergroup) consumergroup = \"$default\";\n      return (\n        `${config.endpoint}${config.entityPath}/ConsumerGroups/${consumergroup}/` +\n        `Partitions/${partitionId}`\n      );\n    };\n\n    (config as EventHubConnectionConfig).getReceiverAddress = (\n      partitionId: string | number,\n      consumergroup?: string\n    ) => {\n      if (!consumergroup) consumergroup = \"$default\";\n      return `${config.entityPath}/ConsumerGroups/${consumergroup}/Partitions/${partitionId}`;\n    };\n    return config as EventHubConnectionConfig;\n  },\n\n  /**\n   * Updates the provided EventHubConnectionConfig to use the custom endpoint address.\n   * @param config - An existing connection configuration to be updated.\n   * @param customEndpointAddress - The custom endpoint address to use.\n   */\n  setCustomEndpointAddress(config: EventHubConnectionConfig, customEndpointAddress: string): void {\n    // The amqpHostname should match the host prior to using the custom endpoint.\n    config.amqpHostname = config.host;\n    const { hostname, port } = parseEndpoint(customEndpointAddress);\n    // Since we specify the port separately, set host to the customEndpointAddress hostname.\n    config.host = hostname;\n    if (port) {\n      config.port = parseInt(port, 10);\n    }\n  },\n\n  /**\n   * Validates the properties of connection config.\n   * @param config - The connection config to be validated.\n   * @returns void\n   */\n  validate(config: EventHubConnectionConfig): void {\n    return ConnectionConfig.validate(config, { isEntityPathRequired: true });\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/* eslint-disable @azure/azure-sdk/ts-no-namespaces */\n/* eslint-disable no-inner-declarations */\n\nimport { logger, logErrorStackTrace } from \"./log\";\nimport { getRuntimeInfo } from \"./util/runtimeInfo\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport { parseEventHubConnectionString } from \"./util/connectionStringUtils\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport {\n  ConnectionContextBase,\n  Constants,\n  CreateConnectionContextBaseParameters,\n  ConnectionConfig\n} from \"@azure/core-amqp\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { ManagementClient, ManagementClientOptions } from \"./managementClient\";\nimport { EventHubClientOptions } from \"./models/public\";\nimport { Connection, ConnectionEvents, Dictionary, EventContext, OnAmqpEvent } from \"rhea-promise\";\nimport { EventHubConnectionConfig } from \"./eventhubConnectionConfig\";\nimport { SharedKeyCredential } from \"./eventhubSharedKeyCredential\";\n\n/**\n * @internal\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenProvider, senders, receivers, etc. about the EventHub client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * The EventHub connection config that is created after\n   * parsing the connection string.\n   */\n  readonly config: EventHubConnectionConfig;\n  /**\n   * The credential to be used for Authentication.\n   * Default value: SharedKeyCredentials.\n   */\n  tokenCredential: SharedKeyCredential | TokenCredential;\n  /**\n   * Indicates whether the close() method was\n   * called on theconnection object.\n   */\n  wasConnectionCloseCalled: boolean;\n  /**\n   * A dictionary of the EventHub Receivers associated with this client.\n   */\n  receivers: Dictionary<EventHubReceiver>;\n  /**\n   * A dictionary of the EventHub Senders associated with this client.\n   */\n  senders: Dictionary<EventHubSender>;\n  /**\n   * A reference to the management session ($management endpoint) on\n   * the underlying amqp connection for the EventHub Client.\n   */\n  managementSession?: ManagementClient;\n  /**\n   * Function returning a promise that resolves once the connectionContext is ready to open an AMQP link.\n   * ConnectionContext will be ready to open an AMQP link when:\n   * - The AMQP connection is already open on both sides.\n   * - The AMQP connection has been closed or disconnected. In this case, a new AMQP connection is expected\n   * to be created first.\n   * An AMQP link cannot be opened if the AMQP connection\n   * is in the process of closing or disconnecting.\n   */\n  readyToOpenLink(): Promise<void>;\n  /**\n   * Closes all AMQP links, sessions and connection.\n   */\n  close(): Promise<void>;\n}\n\n/**\n * Describes the members on the ConnectionContext that are only\n * used by it internally.\n * @internal\n */\nexport interface ConnectionContextInternalMembers extends ConnectionContext {\n  /**\n   * Indicates whether the connection is in the process of closing.\n   * When this returns `true`, a `disconnected` event will be received\n   * after the connection is closed.\n   *\n   */\n  isConnectionClosing(): boolean;\n  /**\n   * Resolves once the context's connection emits a `disconnected` event.\n   */\n  waitForDisconnectedEvent(): Promise<void>;\n  /**\n   * Resolves once the connection has finished being reset.\n   * Connections are reset as part of reacting to a `disconnected` event.\n   */\n  waitForConnectionReset(): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface ConnectionContextOptions extends EventHubClientOptions {\n  managementSessionAddress?: string;\n  managementSessionAudience?: string;\n}\n\n/**\n * Helper type to get the names of all the functions on an object.\n */\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]; // eslint-disable-line @typescript-eslint/ban-types\n/**\n * Helper type to get the types of all the functions on an object.\n */\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n/**\n * Helper type to get the types of all the functions on ConnectionContext\n * and the internal methods from ConnectionContextInternalMembers.\n * Note that this excludes the functions that ConnectionContext inherits.\n * Each function also has its `this` type set as `ConnectionContext`.\n */\ntype ConnectionContextMethods = Omit<\n  FunctionProperties<ConnectionContextInternalMembers>,\n  FunctionPropertyNames<ConnectionContextBase>\n> &\n  ThisType<ConnectionContextInternalMembers>;\n\n/**\n * @internal\n */\nexport namespace ConnectionContext {\n  /**\n   * The user agent string for the EventHubs client.\n   * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk\n   */\n  const userAgent: string = `azsdk-js-azureeventhubs/${\n    packageJsonInfo.version\n  } (${getRuntimeInfo()})`;\n\n  export function getUserAgent(options: ConnectionContextOptions): string {\n    const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;\n    if (finalUserAgent.length > Constants.maxUserAgentLength) {\n      throw new Error(\n        `The user-agent string cannot be more than ${Constants.maxUserAgentLength} characters in length.` +\n          `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`\n      );\n    }\n    return finalUserAgent;\n  }\n\n  export function create(\n    config: EventHubConnectionConfig,\n    tokenCredential: SharedKeyCredential | TokenCredential,\n    options?: ConnectionContextOptions\n  ): ConnectionContext {\n    if (!options) options = {};\n\n    config.webSocket = options.webSocketOptions && options.webSocketOptions.webSocket;\n    config.webSocketEndpointPath = \"$servicebus/websocket\";\n    config.webSocketConstructorOptions =\n      options.webSocketOptions && options.webSocketOptions.webSocketConstructorOptions;\n\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      // re-enabling this will be a post-GA discussion.\n      // dataTransformer: options.dataTransformer,\n      isEntityPathRequired: true,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent: getUserAgent(options),\n        version: packageJsonInfo.version\n      }\n    };\n    // Let us create the base context and then add EventHub specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.tokenCredential = tokenCredential;\n    connectionContext.wasConnectionCloseCalled = false;\n    connectionContext.senders = {};\n    connectionContext.receivers = {};\n    const mOptions: ManagementClientOptions = {\n      address: options.managementSessionAddress,\n      audience: options.managementSessionAudience\n    };\n    connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);\n\n    let waitForConnectionRefreshResolve: () => void;\n    let waitForConnectionRefreshPromise: Promise<void> | undefined;\n\n    Object.assign<ConnectionContext, ConnectionContextMethods>(connectionContext, {\n      isConnectionClosing() {\n        // When the connection is not open, but the remote end is open,\n        // then the rhea connection is in the process of terminating.\n        return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());\n      },\n      async readyToOpenLink() {\n        // Check that the connection isn't in the process of closing.\n        // This can happen when the idle timeout has been reached but\n        // the underlying socket is waiting to be destroyed.\n        if (this.isConnectionClosing()) {\n          // Wait for the disconnected event that indicates the underlying socket has closed.\n          await this.waitForDisconnectedEvent();\n        }\n\n        // Wait for the connection to be reset.\n        await this.waitForConnectionReset();\n      },\n      waitForDisconnectedEvent() {\n        return new Promise((resolve) => {\n          logger.verbose(\n            `[${this.connectionId}] Attempting to reinitialize connection` +\n              ` but the connection is in the process of closing.` +\n              ` Waiting for the disconnect event before continuing.`\n          );\n          this.connection.once(ConnectionEvents.disconnected, resolve);\n        });\n      },\n      waitForConnectionReset() {\n        // Check if the connection is currently in the process of disconnecting.\n        if (waitForConnectionRefreshPromise) {\n          return waitForConnectionRefreshPromise;\n        }\n        return Promise.resolve();\n      },\n      async close() {\n        try {\n          if (this.connection.isOpen()) {\n            // Close all the senders.\n            for (const senderName of Object.keys(this.senders)) {\n              await this.senders[senderName].close();\n            }\n            // Close all the receivers.\n            for (const receiverName of Object.keys(this.receivers)) {\n              await this.receivers[receiverName].close();\n            }\n            // Close the cbs session;\n            await this.cbsSession.close();\n            // Close the management session\n            await this.managementSession!.close();\n            await this.connection.close();\n            this.wasConnectionCloseCalled = true;\n            logger.info(\"Closed the amqp connection '%s' on the client.\", this.connectionId);\n          }\n        } catch (err) {\n          const errorDescription =\n            err instanceof Error ? `${err.name}: ${err.message}` : JSON.stringify(err);\n          logger.warning(\n            `An error occurred while closing the connection \"${this.connectionId}\":\\n${errorDescription}`\n          );\n          logErrorStackTrace(err);\n          throw err;\n        }\n      }\n    });\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = () => {\n      connectionContext.wasConnectionCloseCalled = false;\n      logger.verbose(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled\n      );\n    };\n\n    const onDisconnected: OnAmqpEvent = async (context: EventContext) => {\n      if (waitForConnectionRefreshPromise) {\n        return;\n      }\n      waitForConnectionRefreshPromise = new Promise((resolve) => {\n        waitForConnectionRefreshResolve = resolve;\n      });\n\n      logger.verbose(\n        \"[%s] 'disconnected' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n      const state: Readonly<{\n        wasConnectionCloseCalled: boolean;\n        numSenders: number;\n        numReceivers: number;\n      }> = {\n        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n        numSenders: Object.keys(connectionContext.senders).length,\n        numReceivers: Object.keys(connectionContext.receivers).length\n      };\n      logger.verbose(\n        \"[%s] Closing all open senders and receivers in the state: %O\",\n        connectionContext.connection.id,\n        state\n      );\n\n      // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n      // connection is back up.\n      connectionContext.connection.removeAllSessions();\n\n      // Close the cbs session to ensure all the event handlers are released.\n      await connectionContext.cbsSession.close().catch(() => {\n        /* error already logged, swallow it here */\n      });\n      // Close the management session to ensure all the event handlers are released.\n      await connectionContext.managementSession!.close().catch(() => {\n        /* error already logged, swallow it here */\n      });\n\n      // Close all senders and receivers to ensure clean up of timers & other resources.\n      if (state.numSenders || state.numReceivers) {\n        for (const senderName of Object.keys(connectionContext.senders)) {\n          const sender = connectionContext.senders[senderName];\n          await sender.close().catch(() => {\n            /* error already logged, swallow it here */\n          });\n        }\n        for (const receiverName of Object.keys(connectionContext.receivers)) {\n          const receiver = connectionContext.receivers[receiverName];\n          await receiver.close().catch(() => {\n            /* error already logged, swallow it here */\n          });\n        }\n      }\n\n      await refreshConnection(connectionContext);\n      waitForConnectionRefreshResolve();\n      waitForConnectionRefreshPromise = undefined;\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'protocol_error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    function addConnectionListeners(connection: Connection): void {\n      // Add listeners on the connection object.\n      connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n      connection.on(ConnectionEvents.disconnected, onDisconnected);\n      connection.on(ConnectionEvents.protocolError, protocolError);\n      connection.on(ConnectionEvents.error, error);\n    }\n\n    function cleanConnectionContext(context: ConnectionContext): Promise<void> {\n      // Remove listeners from the connection object.\n      context.connection.removeListener(ConnectionEvents.connectionOpen, onConnectionOpen);\n      context.connection.removeListener(ConnectionEvents.disconnected, onDisconnected);\n      context.connection.removeListener(ConnectionEvents.protocolError, protocolError);\n      context.connection.removeListener(ConnectionEvents.error, error);\n      // Close the connection\n      return context.connection.close();\n    }\n\n    async function refreshConnection(context: ConnectionContext): Promise<void> {\n      const originalConnectionId = context.connectionId;\n      try {\n        await cleanConnectionContext(context);\n      } catch (err) {\n        logger.verbose(\n          `[${context.connectionId}] There was an error closing the connection before reconnecting: %O`,\n          err\n        );\n      }\n\n      // Create a new connection, id, locks, and cbs client.\n      context.refreshConnection();\n      addConnectionListeners(context.connection);\n      logger.verbose(\n        `The connection \"${originalConnectionId}\" has been updated to \"${context.connectionId}\".`\n      );\n    }\n\n    addConnectionListeners(connectionContext.connection);\n\n    logger.verbose(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n    return connectionContext;\n  }\n}\n\n/**\n * Helper method to create a ConnectionContext from the input passed to either\n * EventHubProducerClient or EventHubConsumerClient constructors\n *\n * @internal\n */\nexport function createConnectionContext(\n  hostOrConnectionString: string,\n  eventHubNameOrOptions?: string | EventHubClientOptions,\n  credentialOrOptions?: TokenCredential | EventHubClientOptions,\n  options?: EventHubClientOptions\n): ConnectionContext {\n  let connectionString;\n  let config;\n  let credential: TokenCredential | SharedKeyCredential;\n  hostOrConnectionString = String(hostOrConnectionString);\n\n  if (!isTokenCredential(credentialOrOptions)) {\n    const parsedCS = parseEventHubConnectionString(hostOrConnectionString);\n    if (\n      !(\n        parsedCS.eventHubName ||\n        (typeof eventHubNameOrOptions === \"string\" && eventHubNameOrOptions)\n      )\n    ) {\n      throw new TypeError(\n        `Either provide \"eventHubName\" or the \"connectionString\": \"${hostOrConnectionString}\", ` +\n          `must contain \"EntityPath=<your-event-hub-name>\".`\n      );\n    }\n    if (\n      parsedCS.eventHubName &&\n      typeof eventHubNameOrOptions === \"string\" &&\n      eventHubNameOrOptions &&\n      parsedCS.eventHubName !== eventHubNameOrOptions\n    ) {\n      throw new TypeError(\n        `The entity path \"${parsedCS.eventHubName}\" in connectionString: \"${hostOrConnectionString}\" ` +\n          `doesn't match with eventHubName: \"${eventHubNameOrOptions}\".`\n      );\n    }\n    connectionString = hostOrConnectionString;\n    if (typeof eventHubNameOrOptions !== \"string\") {\n      // connectionstring and/or options were passed to constructor\n      config = EventHubConnectionConfig.create(connectionString);\n      options = eventHubNameOrOptions;\n    } else {\n      // connectionstring, eventHubName and/or options were passed to constructor\n      const eventHubName = eventHubNameOrOptions;\n      config = EventHubConnectionConfig.create(connectionString, eventHubName);\n      options = credentialOrOptions;\n    }\n\n    // Since connectionstring was passed, create a SharedKeyCredential\n    credential = SharedKeyCredential.fromConnectionString(connectionString);\n  } else {\n    // host, eventHubName, a TokenCredential and/or options were passed to constructor\n    const eventHubName = eventHubNameOrOptions;\n    let host = hostOrConnectionString;\n    credential = credentialOrOptions;\n    if (!eventHubName) {\n      throw new TypeError(`\"eventHubName\" is missing`);\n    }\n\n    if (!host.endsWith(\"/\")) host += \"/\";\n    connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;EntityPath=${eventHubName}`;\n    config = EventHubConnectionConfig.create(connectionString);\n  }\n\n  if (options?.customEndpointAddress) {\n    EventHubConnectionConfig.setCustomEndpointAddress(config, options.customEndpointAddress);\n  }\n\n  ConnectionConfig.validate(config);\n\n  return ConnectionContext.create(config, credential, options);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CheckpointStore, PartitionOwnership } from \"./eventProcessor\";\nimport { Checkpoint } from \"./partitionProcessor\";\nimport { generate_uuid } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\n\n/**\n * The `EventProcessor` relies on a `CheckpointStore` to store checkpoints and handle partition\n * ownerships. `InMemoryCheckpointStore` is simple partition manager that stores checkpoints and\n * partition ownerships in memory of your program.\n *\n * You can use the `InMemoryCheckpointStore` to get started with using the `EventProcessor`.\n * But in production, you should choose an implementation of the `CheckpointStore` interface that will\n * store the checkpoints and partition ownerships to a durable store instead.\n *\n * @internal\n */\nexport class InMemoryCheckpointStore implements CheckpointStore {\n  private _partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  private _committedCheckpoints: Map<string, Map<string, Checkpoint>> = new Map();\n\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @returns Partition ownership details of all the partitions that have/had an owner..\n   */\n  async listOwnership(\n    _fullyQualifiedNamespace: string,\n    _eventHubName: string,\n    _consumerGroup: string\n  ): Promise<PartitionOwnership[]> {\n    const ownerships = [];\n\n    for (const value of this._partitionOwnershipMap.values()) {\n      ownerships.push({ ...value });\n    }\n\n    return ownerships;\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership - The list of partition ownership this instance is claiming to own.\n   * @returns A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]> {\n    const claimedOwnerships = [];\n\n    for (const ownership of partitionOwnership) {\n      if (\n        !this._partitionOwnershipMap.has(ownership.partitionId) ||\n        this._partitionOwnershipMap.get(ownership.partitionId)!.etag === ownership.etag\n      ) {\n        const date = new Date();\n\n        const newOwnership = {\n          ...ownership,\n          etag: generate_uuid(),\n          lastModifiedTimeInMs: date.getTime()\n        };\n\n        this._partitionOwnershipMap.set(newOwnership.partitionId, newOwnership);\n        claimedOwnerships.push(newOwnership);\n      }\n    }\n    return claimedOwnerships;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint - The checkpoint.\n   */\n  async updateCheckpoint(checkpoint: Checkpoint): Promise<void> {\n    throwTypeErrorIfParameterMissing(\n      \"\",\n      \"updateCheckpoint\",\n      \"sequenceNumber\",\n      checkpoint.sequenceNumber\n    );\n    throwTypeErrorIfParameterMissing(\"\", \"updateCheckpoint\", \"offset\", checkpoint.offset);\n\n    checkpoint = { ...checkpoint };\n\n    const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);\n    if (partitionOwnership) {\n      partitionOwnership.etag = generate_uuid();\n\n      const key = `${checkpoint.fullyQualifiedNamespace}:${checkpoint.eventHubName}:${checkpoint.consumerGroup}`;\n      let partitionMap = this._committedCheckpoints.get(key);\n\n      if (partitionMap == null) {\n        partitionMap = new Map();\n        this._committedCheckpoints.set(key, partitionMap);\n      }\n\n      partitionMap.set(checkpoint.partitionId, checkpoint);\n    }\n  }\n\n  async listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]> {\n    const key = `${fullyQualifiedNamespace}:${eventHubName}:${consumerGroup}`;\n\n    const partitionMap = this._committedCheckpoints.get(key);\n\n    if (partitionMap == null) {\n      return [];\n    }\n\n    const checkpoints = [];\n\n    for (const value of partitionMap.values()) {\n      checkpoints.push({ ...value });\n    }\n\n    return checkpoints;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"../util/operationOptions\";\nimport { RetryOptions, WebSocketOptions } from \"@azure/core-amqp\";\n\n/**\n * The set of options to configure the behavior of `getEventHubProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetEventHubPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionIds`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionIdsOptions extends OperationOptions {}\n\n/**\n * Options to configure the `sendBatch` method on the `EventHubProducerClient`\n * when sending an array of events.\n * If `partitionId` is set, `partitionKey` must not be set and vice versa.\n *\n * - `partitionId`  : The partition this batch will be sent to.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n */\nexport interface SendBatchOptions extends OperationOptions {\n  /**\n   * The partition this batch will be sent to.\n   * If this value is set then partitionKey can not be set.\n   */\n  partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string;\n}\n\n/**\n * The set of options to configure the `send` operation on the `EventHubProducer`.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo'\n * }\n * ```\n *\n * @internal\n */\nexport interface SendOptions extends OperationOptions {\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string;\n}\n\n/**\n * An enum representing the different reasons for an `EventHubConsumerClient` to stop processing\n * events from a partition in a consumer group of an Event Hub.\n */\nexport enum CloseReason {\n  /**\n   * Ownership of the partition was lost or transitioned to a new processor instance.\n   */\n  OwnershipLost = \"OwnershipLost\",\n  /**\n   * The EventProcessor was shutdown.\n   */\n  Shutdown = \"Shutdown\"\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubClient.\n * - `userAgent`        : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client/producer/consumer.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n *\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n */\nexport interface EventHubClientOptions {\n  /**\n   * A custom endpoint to use when connecting to the Event Hubs service.\n   * This can be useful when your network does not allow connecting to the\n   * standard Azure Event Hubs endpoint address, but does allow connecting\n   * through an intermediary.\n   *\n   * Example: \"https://my.custom.endpoint:100/\"\n   */\n  customEndpointAddress?: string;\n  /**\n   * Options to configure the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   *\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * Value that is appended to the built in user agent string that is passed to the Event Hubs service.\n   */\n  userAgent?: string;\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubConsumerClient.\n * - `loadBalancingOptions`: Options to tune how the EventHubConsumerClient claims partitions.\n * - `userAgent`        : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client/producer/consumer.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n *\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n */\nexport interface EventHubConsumerClientOptions extends EventHubClientOptions {\n  /**\n   * Options to tune how the EventHubConsumerClient claims partitions.\n   */\n  loadBalancingOptions?: LoadBalancingOptions;\n}\n\n/**\n * An options bag to configure load balancing settings.\n */\nexport interface LoadBalancingOptions {\n  /**\n   * Whether to apply a greedy or a more balanced approach when\n   * claiming partitions.\n   *\n   * - balanced: The `EventHubConsumerClient` will take a measured approach to\n   * requesting partition ownership when balancing work with other clients,\n   * slowly claiming partitions until a stabilized distribution is achieved.\n   *\n   * - greedy: The `EventHubConsumerClient` will attempt to claim ownership\n   * of its fair share of partitions aggressively when balancing work with\n   * other clients.\n   *\n   * This option is ignored when either:\n   *   - `CheckpointStore` is __not__ provided to the `EventHubConsumerClient`.\n   *   - `subscribe()` is called for a single partition.\n   * Default: balanced\n   */\n  strategy?: \"balanced\" | \"greedy\";\n  /**\n   * The length of time between attempts to claim partitions.\n   * Default: 10000\n   */\n  updateIntervalInMs?: number;\n  /**\n   * The length of time a partition claim is valid.\n   * Default: 60000\n   */\n  partitionOwnershipExpirationIntervalInMs?: number;\n}\n\n/**\n * Options to configure the `createBatch` method on the `EventHubProducerClient`.\n * - `partitionKey`  : A value that is hashed to produce a partition assignment.\n * - `maxSizeInBytes`: The upper limit for the size of batch.\n * - `abortSignal`   : A signal the request to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo',\n *     maxSizeInBytes: 1024 * 1024 // 1 MB\n * }\n * ```\n */\nexport interface CreateBatchOptions extends OperationOptions {\n  /**\n   * A value that is hashed to produce a partition assignment. It guarantees that messages\n   * with the same partitionKey end up in the same partition.\n   * If this value is set then partitionId can not be set.\n   */\n  partitionKey?: string;\n  /**\n   * The partition this batch will be sent to.\n   * If this value is set then partitionKey can not be set.\n   */\n  partitionId?: string;\n  /**\n   * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   */\n  maxSizeInBytes?: number;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DeliveryAnnotations, Message as RheaMessage, MessageAnnotations } from \"rhea-promise\";\nimport { Constants } from \"@azure/core-amqp\";\nimport { isDefined } from \"./util/typeGuards\";\n\n/**\n * Describes the delivery annotations.\n * @hidden\n */\nexport interface EventHubDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * Map containing message attributes that will be held in the message header.\n * @hidden\n */\nexport interface EventHubMessageAnnotations extends MessageAnnotations {\n  /**\n   * Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * Any other annotation that can be added to the message.\n   */\n  [x: string]: any;\n}\n\n/**\n * Describes the structure of an event to be sent or received from the EventHub.\n * @hidden\n */\nexport interface EventDataInternal {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc?: Date;\n  /**\n   * If specified EventHub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey?: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset?: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * The application specific properties.\n   */\n  properties?: { [property: string]: any };\n  /**\n   * The last sequence number of the event within the partition stream of the Event Hub.\n   */\n  lastSequenceNumber?: number;\n  /**\n   * The offset of the last enqueued event.\n   */\n  lastEnqueuedOffset?: string;\n  /**\n   * The enqueued UTC time of the last event.\n   */\n  lastEnqueuedTime?: Date;\n  /**\n   * The time when the runtime info was retrieved\n   */\n  retrievalTime?: Date;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: { [property: string]: any };\n}\n\nconst messagePropertiesMap = {\n  message_id: \"messageId\",\n  user_id: \"userId\",\n  to: \"to\",\n  subject: \"subject\",\n  reply_to: \"replyTo\",\n  correlation_id: \"correlationId\",\n  content_type: \"contentType\",\n  content_encoding: \"contentEncoding\",\n  absolute_expiry_time: \"absoluteExpiryTime\",\n  creation_time: \"creationTime\",\n  group_id: \"groupId\",\n  group_sequence: \"groupSequence\",\n  reply_to_group_id: \"replyToGroupId\"\n} as const;\n\n/**\n * Converts the AMQP message to an EventData.\n * @param msg - The AMQP message that needs to be converted to EventData.\n * @hidden\n */\nexport function fromRheaMessage(msg: RheaMessage): EventDataInternal {\n  const data: EventDataInternal = {\n    body: msg.body\n  };\n\n  if (msg.message_annotations) {\n    for (const annotationKey of Object.keys(msg.message_annotations)) {\n      switch (annotationKey) {\n        case Constants.partitionKey:\n          data.partitionKey = msg.message_annotations[annotationKey];\n          break;\n        case Constants.sequenceNumber:\n          data.sequenceNumber = msg.message_annotations[annotationKey];\n          break;\n        case Constants.enqueuedTime:\n          data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);\n          break;\n        case Constants.offset:\n          data.offset = msg.message_annotations[annotationKey];\n          break;\n        default:\n          if (!data.systemProperties) {\n            data.systemProperties = {};\n          }\n          data.systemProperties[annotationKey] = msg.message_annotations[annotationKey];\n          break;\n      }\n    }\n  }\n  if (msg.application_properties) {\n    data.properties = msg.application_properties;\n  }\n  if (msg.delivery_annotations) {\n    data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;\n    data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;\n    data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc as number);\n    data.retrievalTime = new Date(\n      msg.delivery_annotations.runtime_info_retrieval_time_utc as number\n    );\n  }\n\n  const messageProperties = Object.keys(messagePropertiesMap) as Array<\n    keyof typeof messagePropertiesMap\n  >;\n  for (const messageProperty of messageProperties) {\n    if (!data.systemProperties) {\n      data.systemProperties = {};\n    }\n    if (msg[messageProperty] != null) {\n      data.systemProperties[messagePropertiesMap[messageProperty]] = msg[messageProperty];\n    }\n  }\n\n  return data;\n}\n\n/**\n * Converts an EventData object to an AMQP message.\n * @param data - The EventData object that needs to be converted to an AMQP message.\n * @param partitionKey - An optional key to determine the partition that this event should land in.\n * @hidden\n */\nexport function toRheaMessage(data: EventData, partitionKey?: string): RheaMessage {\n  const msg: RheaMessage = {\n    body: data.body\n  };\n  // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,\n  // it is equivalent to a message-annotations section containing anempty map of annotations.\n  msg.message_annotations = {};\n  if (data.properties) {\n    msg.application_properties = data.properties;\n  }\n  if (isDefined(partitionKey)) {\n    msg.message_annotations[Constants.partitionKey] = partitionKey;\n    // Event Hub service cannot route messages to a specific partition based on the partition key\n    // if AMQP message header is an empty object. Hence we make sure that header is always present\n    // with atleast one property. Setting durable to true, helps us achieve that.\n    msg.durable = true;\n  }\n\n  return msg;\n}\n\n/**\n * The interface that describes the data to be sent to Event Hub.\n * Use this as a reference when creating the object to be sent when using the `EventHubProducerClient`.\n * For example, `{ body: \"your-data\" }` or\n * ```\n * {\n *    body: \"your-data\",\n *    properties: {\n *       propertyName: \"property value\"\n *    }\n * }\n */\nexport interface EventData {\n  /**\n   * The message body that needs to be sent.\n   * If the application reading the events is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n  /**\n   * Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * The interface that describes the structure of the event received from Event Hub.\n * Use this as a reference when creating the `processEvents` function to process the events\n * recieved from an Event Hub when using the `EventHubConsumerClient`.\n */\nexport interface ReceivedEventData {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The application specific properties.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc: Date;\n  /**\n   * When specified Event Hub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber: number;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: {\n    [key: string]: any;\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, ErrorNameConditionMapper, translate } from \"@azure/core-amqp\";\nimport { isDefined, objectHasProperty } from \"./util/typeGuards\";\n\n/**\n * Represents the position of an event in an Event Hub partition, typically used when calling the `subscribe()`\n * method on an `EventHubConsumerClient` to specify the position in the partition to begin receiving events from.\n *\n * To get an EventPosition representing the start or end of the stream, use the constants\n * `earliestEventPosition` and `latestEventPosition` respectively.\n *\n */\nexport interface EventPosition {\n  /**\n   * The offset of the event identified by this position.\n   * Expected to be undefined if the position is just created from a sequence number or an enqueued time.\n   *\n   * The offset is the relative position for an event in the context of the partition.\n   * The offset should not be considered a stable value.\n   * The same offset may refer to a different event as events reach the age limit for\n   * retention and are no longer visible within the partition.\n   */\n  offset?: number | \"@latest\";\n  /**\n   * Indicates if the specified offset is inclusive of the event which it identifies.\n   * This information is only relevent if the event position was identified by an offset or sequence number.\n   * Default value: `false`.\n   */\n  isInclusive?: boolean;\n  /**\n   * The enqueued time in UTC of the event identified by this position.\n   * When provided as a number this value is the number of milliseconds since the Unix Epoch.\n   * Expected to be undefined if the position is just created from a sequence number or an offset.\n   */\n  enqueuedOn?: Date | number;\n\n  /**\n   * The sequence number of the event identified by this position.\n   * Expected to be undefined if the position is just created from an offset or enqueued time.\n   */\n  sequenceNumber?: number;\n}\n\n/**\n * @internal\n * Gets the expression to be set as the filter clause when creating the receiver\n * @returns filterExpression\n */\nexport function getEventPositionFilter(eventPosition: EventPosition): string {\n  let result;\n  // order of preference\n  if (isDefined(eventPosition.offset)) {\n    result = eventPosition.isInclusive\n      ? `${Constants.offsetAnnotation} >= '${eventPosition.offset}'`\n      : `${Constants.offsetAnnotation} > '${eventPosition.offset}'`;\n  } else if (isDefined(eventPosition.sequenceNumber)) {\n    result = eventPosition.isInclusive\n      ? `${Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`\n      : `${Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;\n  } else if (isDefined(eventPosition.enqueuedOn)) {\n    const time =\n      eventPosition.enqueuedOn instanceof Date\n        ? eventPosition.enqueuedOn.getTime()\n        : eventPosition.enqueuedOn;\n    result = `${Constants.enqueuedTimeAnnotation} > '${time}'`;\n  }\n\n  if (!result) {\n    throw translate({\n      condition: ErrorNameConditionMapper.ArgumentError,\n      description: \"No starting position was set in the EventPosition.\"\n    });\n  }\n  return result;\n}\n\n/**\n * @internal\n */\nexport function isLatestPosition(eventPosition: EventPosition): boolean {\n  if (eventPosition.offset === \"@latest\") {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the `EventPosition` corresponding to the location of the the first event present in the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * first event in the partition which has not expired due to the retention policy.\n */\nexport const earliestEventPosition: EventPosition = {\n  offset: -1\n};\n\n/**\n * Gets the `EventPosition` corresponding to the end of the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * event that is enqueued right after the method call.\n * @returns EventPosition\n */\nexport const latestEventPosition: EventPosition = {\n  offset: \"@latest\"\n};\n\n/**\n * @internal\n */\nexport function validateEventPositions(\n  position: EventPosition | { [partitionId: string]: EventPosition }\n): void {\n  if (!isDefined(position)) {\n    return;\n  }\n\n  const keys = Object.keys(position);\n\n  if (!keys.length) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n\n  if (isEventPosition(position)) {\n    validateEventPosition(position);\n    return;\n  }\n\n  const positions = position as { [partitionId: string]: EventPosition };\n  for (let i = 0; i < keys.length; i++) {\n    if (Object.prototype.hasOwnProperty.call(positions, keys[i])) {\n      validateEventPosition(positions[keys[i]]);\n    }\n  }\n}\n\n/**\n * Determines whether a position is an EventPosition.\n * Does not validate that the position is allowed.\n * @internal\n */\nexport function isEventPosition(position: unknown): position is EventPosition {\n  if (!position) {\n    return false;\n  }\n\n  if (objectHasProperty(position, \"offset\") && isDefined(position.offset)) {\n    return true;\n  }\n\n  if (objectHasProperty(position, \"sequenceNumber\") && isDefined(position.sequenceNumber)) {\n    return true;\n  }\n\n  if (objectHasProperty(position, \"enqueuedOn\") && isDefined(position.enqueuedOn)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateEventPosition(position: EventPosition): void {\n  if (!isDefined(position)) {\n    return;\n  }\n  const offsetPresent = isDefined(position.offset);\n  const sequenceNumberPresent = isDefined(position.sequenceNumber);\n  const enqueuedOnPresent = isDefined(position.enqueuedOn);\n\n  if (\n    (offsetPresent && sequenceNumberPresent) ||\n    (offsetPresent && enqueuedOnPresent) ||\n    (enqueuedOnPresent && sequenceNumberPresent)\n  ) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Set only one of offset, sequenceNumber or enqueuedOn properties.\"\n    );\n  }\n\n  if (!offsetPresent && !enqueuedOnPresent && !sequenceNumberPresent) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { message } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { isObjectWithProperties } from \"./util/typeGuards\";\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n * @internal\n * @ingore\n */\nexport const defaultDataTransformer = {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param body - The AMQP message body\n   * @returns The encoded AMQP message body as an AMQP Data type\n   * (data section in rhea terms). Section object with following properties:\n   * - typecode: 117 (0x75)\n   * - content: The given AMQP message body as a Buffer.\n   * - multiple: true | undefined.\n   */\n  encode(body: unknown): any {\n    let result: any;\n    if (isBuffer(body)) {\n      result = message.data_section(body);\n    } else {\n      // string, undefined, null, boolean, array, object, number should end up here\n      // coercing undefined to null as that will ensure that null value will be given to the\n      // customer on receive.\n      if (body === undefined) body = null;\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * A function that takes the body property from an AMQP message\n   * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.\n   * If it cannot decode the body then it returns the body\n   * as-is.\n   * @param body - The AMQP message body\n   * @returns decoded body or the given body as-is.\n   */\n  decode(body: unknown): any {\n    let processedBody: any = body;\n    try {\n      if (isObjectWithProperties(body, [\"content\"]) && isBuffer(body.content)) {\n        // This indicates that we are getting the AMQP described type. Let us try decoding it.\n        processedBody = body.content;\n      }\n      try {\n        // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n        // the original type back\n        const bodyStr: string = processedBody.toString(\"utf8\");\n        processedBody = JSON.parse(bodyStr);\n      } catch (err) {\n        logger.verbose(\n          \"[decode] An error occurred while trying JSON.parse() on the received body. \" +\n            \"The error is %O\",\n          err\n        );\n      }\n    } catch (err) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err\n      );\n    }\n    return processedBody;\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport {\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverOptions as RheaReceiverOptions,\n  types\n} from \"rhea-promise\";\nimport {\n  Constants,\n  MessagingError,\n  delay,\n  translate,\n  RetryConfig,\n  RetryOperationType,\n  retry\n} from \"@azure/core-amqp\";\nimport { EventDataInternal, ReceivedEventData, fromRheaMessage } from \"./eventData\";\nimport { EventHubConsumerOptions } from \"./models/private\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\n\n/**\n * @hidden\n */\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEvent;\n  onError: OnAmqpEvent;\n  onClose: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSessionClose: OnAmqpEvent;\n  newName?: boolean;\n  eventPosition?: EventPosition;\n}\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/**\n * Describes the message handler signature.\n * @internal\n */\nexport type OnMessage = (eventData: ReceivedEventData) => void;\n\n/**\n * Describes the error handler signature.\n * @internal\n */\nexport type OnError = (error: MessagingError | Error) => void;\n\n/**\n * Describes the abort handler signature.\n * @internal\n */\nexport type OnAbort = () => void;\n\n/**\n * Describes the EventHubReceiver that will receive event data from EventHub.\n * @internal\n */\nexport class EventHubReceiver extends LinkEntity {\n  /**\n   * The EventHub consumer group from which the receiver will\n   * receive messages. (Default: \"default\").\n   */\n  consumerGroup: string;\n  /**\n   * The receiver runtime info.\n   */\n  runtimeInfo: LastEnqueuedEventProperties;\n  /**\n   * The Receiver ownerLevel.\n   */\n  ownerLevel?: number;\n  /**\n   * The event position in the partition at which to start receiving messages.\n   */\n  eventPosition: EventPosition;\n  /**\n   * Optional properties that can be set while creating\n   * the EventHubConsumer.\n   */\n  options: EventHubConsumerOptions;\n  /**\n   * The RHEA AMQP-based receiver link.\n   */\n  private _receiver?: Receiver;\n  /**\n   * The message handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onMessage?: OnMessage;\n  /**\n   * The error handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onError?: OnError;\n  /**\n   * The abort handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onAbort?: OnAbort;\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal cancelling a receiver operation.\n   */\n  private _abortSignal?: AbortSignalLike;\n  /**\n   * The sequence number of the most recently received AMQP message.\n   */\n  private _checkpoint: number = -1;\n  /**\n   * A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`\n   */\n  private _internalQueue: ReceivedEventData[] = [];\n  /**\n   * Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`\n   */\n  private _usingInternalQueue: boolean = false;\n  /**\n   * Indicates if messages are being received from this receiver.\n   */\n  private _isReceivingMessages: boolean = false;\n  /**\n   * Indicated if messages are being received in streaming mode.\n   */\n  private _isStreaming: boolean = false;\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  /**\n   * Returns sequenceNumber of the last event received from the service. This will not match the\n   * last event received by `EventHubConsumer` when the `_internalQueue` is not empty\n   * @readonly\n   */\n  get checkpoint(): number {\n    return this._checkpoint;\n  }\n\n  /**\n   * Indicates if messages are being received from this receiver.\n   * @readonly\n   */\n  get isReceivingMessages(): boolean {\n    return this._isReceivingMessages;\n  }\n\n  /**\n   * Indicates if the receiver has been closed.\n   */\n  get isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /**\n   * The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventProperties` option is set to true\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this.runtimeInfo;\n  }\n\n  /**\n   * Instantiates a receiver that can be used to receive events over an AMQP receiver link in\n   * either batching or streaming mode.\n   * @hidden\n   * @param context -        The connection context corresponding to the EventHubClient instance\n   * @param consumerGroup -  The consumer group from which the receiver should receive events from.\n   * @param partitionId -    The Partition ID from which to receive.\n   * @param eventPosition -  The position in the stream from where to start receiving events.\n   * @param options -      Receiver options.\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options: EventHubConsumerOptions = {}\n  ) {\n    super(context, {\n      partitionId: partitionId,\n      name: context.config.getReceiverAddress(partitionId, consumerGroup)\n    });\n    this.consumerGroup = consumerGroup;\n    this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);\n    this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);\n    this.ownerLevel = options.ownerLevel;\n    this.eventPosition = eventPosition;\n    this.options = options;\n    this.runtimeInfo = {};\n  }\n\n  private _onAmqpMessage(context: EventContext): void {\n    if (!context.message) {\n      return;\n    }\n\n    const data: EventDataInternal = fromRheaMessage(context.message);\n    const receivedEventData: ReceivedEventData = {\n      body: defaultDataTransformer.decode(context.message.body),\n      properties: data.properties,\n      offset: data.offset!,\n      sequenceNumber: data.sequenceNumber!,\n      enqueuedTimeUtc: data.enqueuedTimeUtc!,\n      partitionKey: data.partitionKey!,\n      systemProperties: data.systemProperties\n    };\n\n    this._checkpoint = receivedEventData.sequenceNumber;\n\n    if (this.options.trackLastEnqueuedEventProperties && data) {\n      this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;\n      this.runtimeInfo.enqueuedOn = data.lastEnqueuedTime;\n      this.runtimeInfo.offset = data.lastEnqueuedOffset;\n      this.runtimeInfo.retrievedOn = data.retrievalTime;\n    }\n\n    // Add to internal queue if\n    // - There are no listeners, we are probably getting events due to pending credits\n    // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained\n    if (!this._onMessage || this._usingInternalQueue) {\n      this._internalQueue.push(receivedEventData);\n    } else {\n      if (this._isStreaming) {\n        this._addCredit(1);\n      }\n      this._onMessage(receivedEventData);\n    }\n  }\n\n  private _onAmqpError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    const amqpError = rheaReceiver && rheaReceiver.error;\n    logger.verbose(\n      \"[%s] 'receiver_error' event occurred on the receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      amqpError\n    );\n\n    if (this._onError && amqpError) {\n      const error = translate(amqpError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private _onAmqpSessionError(context: EventContext): void {\n    const sessionError = context.session && context.session.error;\n    logger.verbose(\n      \"[%s] 'session_error' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      sessionError\n    );\n\n    if (this._onError && sessionError) {\n      const error = translate(sessionError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private async _onAmqpClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s'. \" +\n        \"Value for isItselfClosed on the receiver is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'receiver_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  private async _onAmqpSessionClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'session_close' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"Value for isSessionItselfClosed on the session is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isSessionItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'session_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  async abort(): Promise<void> {\n    const desc: string =\n      `[${this._context.connectionId}] The receive operation on the Receiver \"${this.name}\" with ` +\n      `address \"${this.address}\" has been cancelled by the user.`;\n    // Cancellation is user-intended, so log to info instead of warning.\n    logger.info(desc);\n    if (this._onError) {\n      const error = new AbortError(\"The receive operation has been cancelled by the user.\");\n      this._onError(error);\n    }\n    this.clearHandlers();\n    await this.close();\n  }\n\n  /**\n   * Clears the user-provided handlers and updates the receiving messages flag.\n   * @hidden\n   */\n  clearHandlers(): void {\n    if (this._abortSignal && this._onAbort) {\n      this._abortSignal.removeEventListener(\"abort\", this._onAbort);\n    }\n\n    this._abortSignal = undefined;\n    this._onAbort = undefined;\n    this._onError = undefined;\n    this._onMessage = undefined;\n    this._isReceivingMessages = false;\n    this._isStreaming = false;\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   * @hidden\n   */\n  async close(): Promise<void> {\n    try {\n      this.clearHandlers();\n\n      if (!this._receiver) {\n        return;\n      }\n\n      const receiverLink = this._receiver;\n      this._deleteFromCache();\n      await this._closeLink(receiverLink);\n    } catch (err) {\n      const msg = `[${this._context.connectionId}] An error occurred while closing receiver ${this.name}: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @hidden\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._receiver && this._receiver.isOpen());\n    logger.verbose(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers the user's onMessage and onError handlers.\n   * Sends buffered events from the queue before adding additional credits to the AMQP link.\n   * @hidden\n   */\n  registerHandlers(\n    onMessage: OnMessage,\n    onError: OnError,\n    maximumCreditCount: number,\n    isStreaming: boolean,\n    abortSignal?: AbortSignalLike,\n    onAbort?: OnAbort\n  ): void {\n    this._abortSignal = abortSignal;\n    this._onAbort = onAbort;\n    this._onError = onError;\n    this._onMessage = onMessage;\n    this._isStreaming = isStreaming;\n    // indicate that messages are being received.\n    this._isReceivingMessages = true;\n\n    this._useInternalQueue(onMessage, abortSignal)\n      .then(async (processedEventCount) => {\n        if (this._onMessage !== onMessage) {\n          // the original handler has been removed, so no further action required.\n          return;\n        }\n\n        // check if more messages are required\n        if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {\n          return;\n        }\n\n        if (!this.isOpen()) {\n          try {\n            await this.initialize();\n            if (abortSignal && abortSignal.aborted) {\n              await this.abort();\n            }\n          } catch (err) {\n            if (this._onError === onError) {\n              onError(err);\n            }\n            return;\n          }\n        } else {\n          logger.verbose(\n            \"[%s] Receiver link already present, hence reusing it.\",\n            this._context.connectionId\n          );\n        }\n        // add credits\n        const existingCredits = this._receiver ? this._receiver.credit : 0;\n        const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;\n        const creditsToAdd = Math.max(\n          maximumCreditCount - (existingCredits + prcoessedEventCountToExclude),\n          0\n        );\n        this._addCredit(creditsToAdd);\n        return;\n      })\n      .catch((err) => {\n        // something really unexpected happened, so attempt to call user's error handler\n        if (this._onError === onError) {\n          onError(err);\n        }\n      });\n  }\n\n  private _addCredit(credit: number): void {\n    if (this._receiver) {\n      this._receiver.addCredit(credit);\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.receivers[this.name];\n    logger.verbose(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name\n    );\n  }\n\n  private async _useInternalQueue(\n    onMessage: OnMessage,\n    abortSignal?: AbortSignalLike\n  ): Promise<number> {\n    let processedMessagesCount = 0;\n    // allow the event loop to process any blocking code outside\n    // this code path before sending any events.\n    await delay(0);\n    this._usingInternalQueue = true;\n    while (this._internalQueue.length) {\n      if (!this._onMessage) {\n        break;\n      }\n\n      if (abortSignal && abortSignal.aborted) {\n        break;\n      }\n\n      // These will not be equal if clearHandlers and registerHandlers were called\n      // in the same tick of the event loop. If onMessage isn't the currently active\n      // handler, it should stop getting messages from the queue.\n      if (this._onMessage !== onMessage) {\n        break;\n      }\n      const eventData = this._internalQueue.splice(0, 1)[0];\n      processedMessagesCount++;\n      onMessage(eventData);\n      // allow the event loop to process any blocking code outside\n      // this code path before sending the next event.\n      await delay(0);\n    }\n    this._usingInternalQueue = false;\n    return processedMessagesCount;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   * @hidden\n   */\n  async initialize(): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        this.isConnecting = true;\n\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim();\n\n        const receiverOptions: CreateReceiverOptions = {\n          onClose: (context: EventContext) => this._onAmqpClose(context),\n          onError: (context: EventContext) => this._onAmqpError(context),\n          onMessage: (context: EventContext) => this._onAmqpMessage(context),\n          onSessionClose: (context: EventContext) => this._onAmqpSessionClose(context),\n          onSessionError: (context: EventContext) => this._onAmqpSessionError(context)\n        };\n        if (this.checkpoint > -1) {\n          receiverOptions.eventPosition = { sequenceNumber: this.checkpoint };\n        }\n        const options = this._createReceiverOptions(receiverOptions);\n\n        logger.verbose(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._receiver = await this._context.connection.createReceiver(options);\n        this.isConnecting = false;\n        logger.verbose(\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        // store the underlying link in a cache\n        this._context.receivers[this.name] = this;\n\n        await this._ensureTokenRenewal();\n      } else {\n        logger.verbose(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      const error = translate(err);\n      logger.warning(\n        \"[%s] An error occured while creating the receiver '%s': %s\",\n        this._context.connectionId,\n        this.name,\n        `${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(err);\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   * @hidden\n   */\n  private _createReceiverOptions(options: CreateReceiverOptions): RheaReceiverOptions {\n    if (options.newName) this.name = uuid();\n    const rcvrOptions: RheaReceiverOptions = {\n      name: this.name,\n      autoaccept: true,\n      source: {\n        address: this.address\n      },\n      credit_window: 0,\n      onMessage: options.onMessage || ((context: EventContext) => this._onAmqpMessage(context)),\n      onError: options.onError || ((context: EventContext) => this._onAmqpError(context)),\n      onClose: options.onClose || ((context: EventContext) => this._onAmqpClose(context)),\n      onSessionError:\n        options.onSessionError || ((context: EventContext) => this._onAmqpSessionError(context)),\n      onSessionClose:\n        options.onSessionClose || ((context: EventContext) => this._onAmqpSessionClose(context))\n    };\n\n    if (typeof this.ownerLevel === \"number\") {\n      rcvrOptions.properties = {\n        [Constants.attachEpoch]: types.wrap_long(this.ownerLevel)\n      };\n    }\n\n    if (this.options.trackLastEnqueuedEventProperties) {\n      rcvrOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n    }\n\n    const eventPosition = options.eventPosition || this.eventPosition;\n    if (eventPosition) {\n      // Set filter on the receiver if event position is specified.\n      const filterClause = getEventPositionFilter(eventPosition);\n      if (filterClause) {\n        (rcvrOptions.source as any).filter = {\n          \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004)\n        };\n      }\n    }\n    return rcvrOptions;\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds - The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @returns Promise<ReceivedEventData[]>.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while receiving a message.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    // store events across multiple retries\n    const receivedEvents: ReceivedEventData[] = [];\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      return new Promise(async (resolve, reject) => {\n        // if this consumer was closed,\n        // resolve the operation's promise with the events collected thus far in case\n        // the promise hasn't already been resolved.\n        if (this._isClosed || this._context.wasConnectionCloseCalled) {\n          return resolve(receivedEvents);\n        }\n\n        let timer: any;\n        const logOnAbort = (): void => {\n          const name = this.name;\n          const address = this.address;\n          const desc: string =\n            `[${this._context.connectionId}] The request operation on the Receiver \"${name}\" with ` +\n            `address \"${address}\" has been cancelled by the user.`;\n          // Cancellation is intentional so logging to 'info'.\n          logger.info(desc);\n        };\n\n        const rejectOnAbort = async (): Promise<void> => {\n          logOnAbort();\n          try {\n            await this.close();\n          } finally {\n            reject(new AbortError(\"The receive operation has been cancelled by the user.\"));\n          }\n        };\n\n        // operation has been cancelled, so exit immediately\n        if (abortSignal && abortSignal.aborted) {\n          return rejectOnAbort();\n        }\n\n        // updates the prefetch count so that the baseConsumer adds\n        // the correct number of credits to receive the same number of events.\n        const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);\n        if (prefetchCount === 0) {\n          return resolve(receivedEvents);\n        }\n\n        logger.verbose(\n          \"[%s] Receiver '%s', setting the prefetch count to %d.\",\n          this._context.connectionId,\n          this.name,\n          prefetchCount\n        );\n\n        const cleanUpBeforeReturn = (): void => {\n          this.clearHandlers();\n          clearTimeout(timer);\n        };\n\n        const onAbort = (): void => {\n          clearTimeout(timer);\n          rejectOnAbort();\n        };\n\n        this.registerHandlers(\n          (eventData) => {\n            receivedEvents.push(eventData);\n\n            // resolve the operation's promise after the requested\n            // number of events are received.\n            if (receivedEvents.length === maxMessageCount) {\n              logger.info(\n                \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                this._context.connectionId,\n                this.name,\n                receivedEvents.length,\n                maxWaitTimeInSeconds\n              );\n              cleanUpBeforeReturn();\n              resolve(receivedEvents);\n            }\n          },\n          (err) => {\n            // restore events to the front of the internal queue.\n            while (receivedEvents.length) {\n              this._internalQueue.unshift(receivedEvents.pop()!);\n            }\n            cleanUpBeforeReturn();\n            if (err.name === \"AbortError\") {\n              rejectOnAbort();\n            } else {\n              reject(err);\n            }\n          },\n          maxMessageCount - receivedEvents.length,\n          false,\n          abortSignal,\n          onAbort\n        );\n\n        const addTimeout = (): void => {\n          const msg = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n          logger.verbose(msg, this._context.connectionId, maxWaitTimeInSeconds, this.name);\n\n          // resolve the operation's promise after the requested\n          // max number of seconds have passed.\n          timer = setTimeout(() => {\n            logger.info(\n              \"[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.\",\n              this._context.connectionId,\n              this.name,\n              receivedEvents.length,\n              maxWaitTimeInSeconds\n            );\n            cleanUpBeforeReturn();\n            resolve(receivedEvents);\n          }, maxWaitTimeInSeconds * 1000);\n        };\n\n        addTimeout();\n        if (abortSignal && !abortSignal.aborted) {\n          abortSignal.addEventListener(\"abort\", onAbort);\n        }\n      });\n    };\n\n    const retryOptions = this.options.retryOptions || {};\n    const config: RetryConfig<ReceivedEventData[]> = {\n      connectionHost: this._context.config.host,\n      connectionId: this._context.connectionId,\n      operation: retrieveEvents,\n      operationType: RetryOperationType.receiveMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<ReceivedEventData[]>(config);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { extractSpanContextFromTraceParentHeader, getTraceParentHeader } from \"@azure/core-tracing\";\nimport { Span, SpanContext } from \"@opentelemetry/api\";\nimport { EventData } from \"../eventData\";\n\n/**\n * @hidden\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `EventData` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `EventData` unless the `EventData`\n * has already been instrumented.\n * @param eventData - The `EventData` to instrument.\n * @param span - The `Span` containing the context to propagate tracing information.\n */\nexport function instrumentEventData(eventData: EventData, span: Span): EventData {\n  if (eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]) {\n    return eventData;\n  }\n\n  // create a copy so the original isn't modified\n  eventData = { ...eventData, properties: { ...eventData.properties } };\n\n  const traceParent = getTraceParentHeader(span.context());\n  if (traceParent) {\n    eventData.properties![TRACEPARENT_PROPERTY] = traceParent;\n  }\n\n  return eventData;\n}\n\n/**\n * Extracts the `SpanContext` from an `EventData` if the context exists.\n * @param eventData - An individual `EventData` object.\n * @internal\n */\nexport function extractSpanContextFromEventData(eventData: EventData): SpanContext | undefined {\n  if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];\n  return extractSpanContextFromTraceParentHeader(diagnosticId);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { EventHubReceiver } from \"./eventHubReceiver\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { MessagingError } from \"@azure/core-amqp\";\nimport { OperationOptions, getParentSpan } from \"./util/operationOptions\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { CanonicalCode, Link, Span, SpanKind } from \"@opentelemetry/api\";\nimport { extractSpanContextFromEventData } from \"./diagnostics/instrumentEventData\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\n\n/**\n * @internal\n */\nexport class PartitionPump {\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: CommonEventProcessorOptions;\n  private _receiver: EventHubReceiver | undefined;\n  private _isReceiving: boolean = false;\n  private _isStopped: boolean = false;\n  private _abortController: AbortController;\n  constructor(\n    private _context: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    private readonly _startPosition: EventPosition,\n    options: CommonEventProcessorOptions\n  ) {\n    this._partitionProcessor = partitionProcessor;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch (err) {\n      // swallow the error from the user-defined code\n      this._partitionProcessor.processError(err);\n    }\n\n    // this is intentionally not await'd - the _receiveEvents loop will continue to\n    // execute and can be stopped by calling .stop()\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    logger.info(\n      `Successfully started the receiver for partition \"${this._partitionProcessor.partitionId}\".`\n    );\n  }\n\n  /**\n   * Creates a new `EventHubReceiver` and replaces any existing receiver.\n   * @param partitionId - The partition the receiver should read messages from.\n   * @param lastSeenSequenceNumber - The sequence number to begin receiving messages from (exclusive).\n   * If `-1`, then the PartitionPump's startPosition will be used instead.\n   */\n  private _setOrReplaceReceiver(\n    partitionId: string,\n    lastSeenSequenceNumber: number\n  ): EventHubReceiver {\n    // Determine what the new EventPosition should be.\n    // If this PartitionPump has received events, we'll start from the last\n    // seen sequenceNumber (exclusive).\n    // Otherwise, use the `_startPosition`.\n    const currentEventPosition: EventPosition =\n      lastSeenSequenceNumber >= 0\n        ? {\n            sequenceNumber: lastSeenSequenceNumber,\n            isInclusive: false\n          }\n        : this._startPosition;\n\n    // Set or replace the PartitionPump's receiver.\n    this._receiver = new EventHubReceiver(\n      this._context,\n      this._partitionProcessor.consumerGroup,\n      partitionId,\n      currentEventPosition,\n      {\n        ownerLevel: this._processorOptions.ownerLevel,\n        trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties,\n        retryOptions: this._processorOptions.retryOptions\n      }\n    );\n\n    return this._receiver;\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    let lastSeenSequenceNumber = -1;\n    let receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n\n    while (this._isReceiving) {\n      try {\n        // Check if the receiver was closed so we can recreate it.\n        if (receiver.isClosed) {\n          receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n        }\n\n        const receivedEvents = await receiver.receiveBatch(\n          this._processorOptions.maxBatchSize,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal\n        );\n\n        if (\n          this._processorOptions.trackLastEnqueuedEventProperties &&\n          receiver.lastEnqueuedEventProperties\n        ) {\n          this._partitionProcessor.lastEnqueuedEventProperties =\n            receiver.lastEnqueuedEventProperties;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n\n        if (receivedEvents.length) {\n          lastSeenSequenceNumber = receivedEvents[receivedEvents.length - 1].sequenceNumber;\n        }\n\n        const span = createProcessingSpan(\n          receivedEvents,\n          {\n            eventHubName: this._context.config.entityPath,\n            host: this._context.config.host\n          },\n          this._processorOptions\n        );\n\n        await trace(() => this._partitionProcessor.processEvents(receivedEvents), span);\n      } catch (err) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        logger.warning(\n          `An error was thrown while receiving or processing events on partition \"${this._partitionProcessor.partitionId}\"`\n        );\n        logErrorStackTrace(err);\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err);\n        } catch (errorFromUser) {\n          // Using verbose over warning because this error is swallowed.\n          logger.verbose(\"An error was thrown by user's processError method: \", errorFromUser);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.code === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (errorFromStop) {\n            // Using verbose over warning because this error is swallowed.\n            logger.verbose(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              errorFromStop\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    if (this._isStopped) {\n      return;\n    }\n    this._isStopped = true;\n    this._isReceiving = false;\n    try {\n      // Trigger the cancellation before closing the receiver,\n      // otherwise the receiver will remove the listener on the abortSignal\n      // before it has a chance to be emitted.\n      this._abortController.abort();\n\n      if (this._receiver) {\n        await this._receiver.close();\n      }\n      await this._partitionProcessor.close(reason);\n    } catch (err) {\n      logger.warning(`An error occurred while closing the receiver: ${err?.name}: ${err?.message}`);\n      logErrorStackTrace(err);\n      this._partitionProcessor.processError(err);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function createProcessingSpan(\n  receivedEvents: ReceivedEventData[],\n  eventHubProperties: { eventHubName: string; host: string },\n  options?: OperationOptions\n): Span {\n  const links: Link[] = [];\n\n  for (const receivedEvent of receivedEvents) {\n    const spanContext = extractSpanContextFromEventData(receivedEvent);\n\n    if (spanContext == null) {\n      continue;\n    }\n\n    links.push({\n      context: spanContext,\n      attributes: {\n        enqueuedTime: receivedEvent.enqueuedTimeUtc.getTime()\n      }\n    });\n  }\n\n  const span = getTracer().startSpan(\"Azure.EventHubs.process\", {\n    kind: SpanKind.CONSUMER,\n    links,\n    parent: getParentSpan(options?.tracingOptions)\n  });\n\n  span.setAttributes({\n    \"az.namespace\": \"Microsoft.EventHub\",\n    \"message_bus.destination\": eventHubProperties.eventHubName,\n    \"peer.address\": eventHubProperties.host\n  });\n\n  return span;\n}\n\n/**\n * @internal\n */\nexport async function trace(fn: () => Promise<void>, span: Span): Promise<void> {\n  try {\n    await fn();\n    span.setStatus({ code: CanonicalCode.OK });\n  } catch (err) {\n    span.setStatus({\n      code: CanonicalCode.UNKNOWN,\n      message: err.message\n    });\n    throw err;\n  } finally {\n    span.end();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventPosition } from \"./eventPosition\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { PartitionPump } from \"./partitionPump\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { ConnectionContext } from \"./connectionContext\";\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @internal\n */\nexport interface PumpManager {\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition - The position in the partition to start reading from.\n   * @param eventHubClient - The EventHubClient to forward to the PartitionPump.\n   * @param partitionProcessor - The PartitionProcessor to forward to the PartitionPump.\n   * @param abortSignal - Used to cancel pump creation.\n   */\n  createPump(\n    startPosition: EventPosition,\n    connectionContext: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void>;\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @param partitionId - The partition to check.\n   */\n  isReceivingFromPartition(partitionId: string): boolean;\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason - The reason for removing the pump.\n   */\n  removeAllPumps(reason: CloseReason): Promise<void>;\n}\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @hidden\n * @internal\n */\nexport class PumpManagerImpl implements PumpManager {\n  private readonly _eventProcessorName: string;\n  private readonly _options: CommonEventProcessorOptions;\n  private _partitionIdToPumps: {\n    [partitionId: string]: PartitionPump | undefined;\n  } = {};\n\n  /**\n   * @hidden\n   */\n  constructor(eventProcessorName: string, eventProcessorOptions: CommonEventProcessorOptions) {\n    this._eventProcessorName = eventProcessorName;\n    this._options = eventProcessorOptions;\n  }\n\n  /**\n   * Returns a list of partitionIds that are actively receiving messages.\n   * @hidden\n   */\n  public receivingFromPartitions(): string[] {\n    return Object.keys(this._partitionIdToPumps).filter((id) => {\n      const pump = this._partitionIdToPumps[id];\n      return Boolean(pump && pump.isReceiving);\n    });\n  }\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @internal\n   */\n  public isReceivingFromPartition(partitionId: string): boolean {\n    const pump = this._partitionIdToPumps[partitionId];\n    return Boolean(pump && pump.isReceiving);\n  }\n\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition - The position in the partition to start reading from.\n   * @param connectionContext - The ConnectionContext to forward to the PartitionPump.\n   * @param partitionProcessor - The PartitionProcessor to forward to the PartitionPump.\n   * @hidden\n   */\n  public async createPump(\n    startPosition: EventPosition,\n    connectionContext: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    const partitionId = partitionProcessor.partitionId;\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `${this._eventProcessorName}] The subscription was closed before creating the pump for partition ${partitionId}.`\n      );\n      return;\n    }\n    // attempt to get an existing pump\n    const existingPump = this._partitionIdToPumps[partitionId];\n    if (existingPump) {\n      if (existingPump.isReceiving) {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] The existing pump is running.`\n        );\n        return;\n      }\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] The existing pump is not running.`\n      );\n      await this.removePump(partitionId, CloseReason.OwnershipLost);\n    }\n\n    logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Creating a new pump.`);\n\n    const pump = new PartitionPump(\n      connectionContext,\n      partitionProcessor,\n      startPosition,\n      this._options\n    );\n\n    try {\n      // Set the pump before starting it in case the user\n      // closes the subscription while `start()` is in progress.\n      this._partitionIdToPumps[partitionId] = pump;\n      await pump.start();\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while adding/updating a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stop a PartitionPump and removes it from the internal map.\n   * @param partitionId - The partitionId to remove the associated PartitionPump from.\n   * @param reason - The reason for removing the pump.\n   * @hidden\n   */\n  public async removePump(partitionId: string, reason: CloseReason): Promise<void> {\n    try {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        delete this._partitionIdToPumps[partitionId];\n        logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Stopping the pump.`);\n        await pump.stop(reason);\n      } else {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] No pump was found to remove.`\n        );\n      }\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while removing a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason - The reason for removing the pump.\n   * @hidden\n   */\n  public async removeAllPumps(reason: CloseReason): Promise<void> {\n    const partitionIds = Object.keys(this._partitionIdToPumps);\n\n    logger.verbose(`[${this._eventProcessorName}] Removing all pumps due to reason ${reason}.`);\n\n    const tasks: PromiseLike<void>[] = [];\n    for (const partitionId of partitionIds) {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        tasks.push(pump.stop(reason));\n      }\n    }\n\n    try {\n      await Promise.all(tasks);\n    } catch (err) {\n      logger.verbose(\n        `[${this._eventProcessorName}] An error occured while removing all pumps: ${err}`\n      );\n      logErrorStackTrace(err);\n    } finally {\n      this._partitionIdToPumps = {};\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CheckpointStore } from \"./eventProcessor\";\nimport { CloseReason } from \"./models/public\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { LastEnqueuedEventProperties } from \"./eventHubReceiver\";\nimport {\n  BasicPartitionProperties,\n  PartitionContext,\n  SubscriptionEventHandlers\n} from \"./eventHubConsumerClientModels\";\nimport { logger } from \"./log\";\n\n/**\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * When the `updateCheckpoint()` method on the `PartitionProcessor` class is called by the user, a\n * `Checkpoint` is created internally. It is then stored in the storage solution implemented by the\n * `CheckpointManager` chosen by the user when creating an `EventProcessor`.\n *\n * Users are never expected to interact with `Checkpoint` directly. This interface exists to support the\n * internal workings of `EventProcessor` and `CheckpointManager`.\n **/\nexport interface Checkpoint {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition\n   */\n  partitionId: string;\n  /**\n   * The sequence number of the event\n   */\n  sequenceNumber: number;\n  /**\n   * The offset of the event.\n   */\n  offset: number;\n}\n\n/**\n * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`\n *\n * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,\n * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method\n * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.\n * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition\n * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.\n * @internal\n */\nexport class PartitionProcessor implements PartitionContext {\n  private _lastEnqueuedEventProperties?: LastEnqueuedEventProperties;\n\n  constructor(\n    private _eventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    private _context: BasicPartitionProperties & {\n      eventProcessorId: string;\n    }\n  ) {}\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this._lastEnqueuedEventProperties!;\n  }\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   */\n  public set lastEnqueuedEventProperties(properties: LastEnqueuedEventProperties) {\n    this._lastEnqueuedEventProperties = properties;\n  }\n\n  /**\n   * The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get fullyQualifiedNamespace(): string {\n    return this._context.fullyQualifiedNamespace;\n  }\n\n  /**\n   * The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get consumerGroup(): string {\n    return this._context.consumerGroup!;\n  }\n\n  /**\n   * The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get eventHubName(): string {\n    return this._context.eventHubName;\n  }\n\n  /**\n   * The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get partitionId(): string {\n    return this._context.partitionId;\n  }\n\n  /**\n   * The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`\n   */\n  public get eventProcessorId(): string {\n    return this._context.eventProcessorId;\n  }\n\n  /**\n   * This method is called when the `EventProcessor` takes ownership of a new partition and before any\n   * events are received.\n   */\n  async initialize(): Promise<void> {\n    if (this._eventHandlers.processInitialize) {\n      await this._eventHandlers.processInitialize(this);\n    }\n  }\n\n  /**\n   * This method is called before the partition processor is closed by the EventProcessor.\n   *\n   * @param reason - The reason for closing this partition processor.\n   */\n  async close(reason: CloseReason): Promise<void> {\n    if (this._eventHandlers.processClose) {\n      await this._eventHandlers.processClose(reason, this);\n    }\n  }\n\n  /**\n   * This method is called when new events are received.\n   *\n   * This is also a good place to update checkpoints as appropriate.\n   *\n   * @param event - The received events to be processed.\n   */\n  async processEvents(events: ReceivedEventData[]): Promise<void> {\n    await this._eventHandlers.processEvents(events, this);\n  }\n\n  /**\n   * This method is called when an error occurs while receiving events from Event Hubs.\n   *\n   * @param error - The error to be processed.\n   */\n  async processError(error: Error): Promise<void> {\n    if (this._eventHandlers.processError) {\n      try {\n        await this._eventHandlers.processError(error, this);\n      } catch (err) {\n        logger.verbose(`Error thrown from user's processError handler : ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Updates the checkpoint using the event data.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param eventData - The event that you want to update the checkpoint with.\n   */\n  public async updateCheckpoint(eventData: ReceivedEventData): Promise<void> {\n    const checkpoint: Checkpoint = {\n      fullyQualifiedNamespace: this._context.fullyQualifiedNamespace,\n      eventHubName: this._context.eventHubName,\n      consumerGroup: this._context.consumerGroup,\n      partitionId: this._context.partitionId,\n      sequenceNumber: eventData.sequenceNumber,\n      offset: eventData.offset\n    };\n\n    await this._checkpointStore!.updateCheckpoint(checkpoint);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay } from \"@azure/core-amqp\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param abortSignal - The abortSignal associated with the containing operation.\n * @internal\n */\nexport async function delayWithoutThrow(\n  delayInMs: number,\n  abortSignal?: AbortSignalLike\n): Promise<void> {\n  try {\n    await delay(delayInMs, abortSignal);\n  } catch {\n    /* no-op to swallow AbortError */\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { PumpManager, PumpManagerImpl } from \"./pumpManager\";\nimport { AbortController, AbortSignalLike, AbortError } from \"@azure/abort-controller\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { Checkpoint, PartitionProcessor } from \"./partitionProcessor\";\nimport { SubscriptionEventHandlers } from \"./eventHubConsumerClientModels\";\nimport { EventPosition, isEventPosition, latestEventPosition } from \"./eventPosition\";\nimport { delayWithoutThrow } from \"./util/delayWithoutThrow\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { CloseReason } from \"./models/public\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LoadBalancingStrategy } from \"./loadBalancerStrategies/loadBalancingStrategy\";\n\n/**\n * An interface representing the details on which instance of a `EventProcessor` owns processing\n * of a given partition from a consumer group of an Event Hub instance.\n *\n * **Note**: This is used internally by the `EventProcessor` and user never has to create it directly.\n */\nexport interface PartitionOwnership {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition.\n   */\n  partitionId: string;\n  /**\n   * The unique identifier of the event processor.\n   */\n  ownerId: string;\n  /**\n   * The last modified time.\n   */\n  lastModifiedTimeInMs?: number;\n  /**\n   * The unique identifier for the operation.\n   */\n  etag?: string;\n}\n\n/**\n * A checkpoint store stores and retrieves partition ownership information and checkpoint details\n * for each partition in a given consumer group of an event hub instance.\n *\n * Users are not meant to implement an `CheckpointStore`.\n * Users are expected to choose existing implementations of this interface, instantiate it, and pass\n * it to the `EventHubConsumerClient` class constructor when instantiating a client.\n * Users are not expected to use any of the methods on a checkpoint store, these are used internally by\n * the client.\n *\n * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n */\nexport interface CheckpointStore {\n  /**\n   * Called to get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @returns A list of partition ownership details of all the partitions that have/had an owner.\n   */\n  listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<PartitionOwnership[]>;\n  /**\n   * Called to claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership - The list of partition ownership this instance is claiming to own.\n   * @returns A list of partitions this instance successfully claimed ownership.\n   */\n  claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint - The checkpoint.\n   */\n  updateCheckpoint(checkpoint: Checkpoint): Promise<void>;\n\n  /**\n   * Lists all the checkpoints in a data store for a given namespace, eventhub and consumer group.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   */\n  listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]>;\n}\n\n/**\n * A set of options to pass to the constructor of `EventProcessor`.\n * You can specify\n * - `maxBatchSize`: The max size of the batch of events passed each time to user code for processing.\n * - `maxWaitTimeInSeconds`: The maximum amount of time to wait to build up the requested message count before\n * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n *\n * Example usage with default values:\n * ```ts\n * {\n *     maxBatchSize: 1,\n *     maxWaitTimeInSeconds: 60,\n * }\n * ```\n * @internal\n */\nexport interface FullEventProcessorOptions extends CommonEventProcessorOptions {\n  /**\n   * An optional pump manager to use, rather than instantiating one internally\n   * @internal\n   */\n  pumpManager?: PumpManager;\n  /**\n   * The amount of time between load balancing attempts.\n   */\n  loopIntervalInMs: number;\n  /**\n   * A specific partition to target.\n   */\n  processingTarget?: string;\n}\n\n/**\n * Event Processor based applications consist of one or more instances of EventProcessor which have been\n * configured to consume events from the same Event Hub and consumer group. They balance the\n * workload across different instances by distributing the partitions to be processed among themselves.\n * They also allow the user to track progress when events are processed using checkpoints.\n *\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * You need the below to create an instance of `EventProcessor`\n * - The name of the consumer group from which you want to process events\n * - An instance of `EventHubClient` class that was created for the Event Hub instance.\n * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the\n * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming\n * events, extend this class and override the `processEvents()` method. For example:\n * ```js\n * class SamplePartitionProcessor extends PartitionProcessor {\n *     async processEvents(events) {\n *        // user code to process events here\n *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class\n *        // use `this.updateCheckpoint()` method to update checkpoints as needed\n *     }\n * }\n * ```\n * - An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.\n * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n *\n * @internal\n */\nexport class EventProcessor {\n  private _processorOptions: FullEventProcessorOptions;\n  private _pumpManager: PumpManager;\n  private _id: string;\n  private _isRunning: boolean = false;\n  private _loopTask?: PromiseLike<void>;\n  private _abortController?: AbortController;\n  /**\n   * A specific partition to target.\n   */\n  private _processingTarget?: string;\n  /**\n   * Determines which partitions to claim as part of load balancing.\n   */\n  private _loadBalancingStrategy: LoadBalancingStrategy;\n  /**\n   * The amount of time between load balancing attempts.\n   */\n  private _loopIntervalInMs: number;\n  private _eventHubName: string;\n  private _fullyQualifiedNamespace: string;\n\n  /**\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param eventHubClient - An instance of `EventHubClient` that was created for the Event Hub instance.\n   * @param PartitionProcessorClass - A user-provided class that extends the `PartitionProcessor` class.\n   * This class will be responsible for processing and checkpointing events.\n   * @param checkpointStore - An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.\n   * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n   * @param options - A set of options to configure the Event Processor\n   * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.\n   * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before\n   * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n   */\n  constructor(\n    private _consumerGroup: string,\n    private _context: ConnectionContext,\n    private _subscriptionEventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ) {\n    if (options.ownerId) {\n      this._id = options.ownerId;\n      logger.verbose(`Starting event processor with ID ${this._id}`);\n    } else {\n      this._id = uuid();\n      logger.verbose(`Starting event processor with autogenerated ID ${this._id}`);\n    }\n\n    this._eventHubName = this._context.config.entityPath;\n    this._fullyQualifiedNamespace = this._context.config.host;\n    this._processorOptions = options;\n    this._pumpManager =\n      options.pumpManager || new PumpManagerImpl(this._id, this._processorOptions);\n    this._processingTarget = options.processingTarget;\n    this._loopIntervalInMs = options.loopIntervalInMs;\n    this._loadBalancingStrategy = options.loadBalancingStrategy;\n  }\n\n  /**\n   * The unique identifier for the EventProcessor.\n   */\n  get id(): string {\n    return this._id;\n  }\n\n  private _createPartitionOwnershipRequest(\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIdToClaim: string\n  ): PartitionOwnership {\n    const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);\n    const partitionOwnership: PartitionOwnership = {\n      ownerId: this._id,\n      partitionId: partitionIdToClaim,\n      fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n      consumerGroup: this._consumerGroup,\n      eventHubName: this._eventHubName,\n      etag: previousPartitionOwnership ? previousPartitionOwnership.etag : undefined\n    };\n\n    return partitionOwnership;\n  }\n\n  /*\n   * Claim ownership of the given partition if it's available\n   */\n  private async _claimOwnership(\n    ownershipRequest: PartitionOwnership,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] Subscription was closed before claiming ownership of ${ownershipRequest.partitionId}.`\n      );\n      return;\n    }\n    logger.info(\n      `[${this._id}] Attempting to claim ownership of partition ${ownershipRequest.partitionId}.`\n    );\n    try {\n      const claimedOwnerships = await this._checkpointStore.claimOwnership([ownershipRequest]);\n\n      // can happen if the partition was claimed out from underneath us - we shouldn't\n      // attempt to spin up a processor.\n      if (!claimedOwnerships.length) {\n        return;\n      }\n\n      logger.info(\n        `[${this._id}] Successfully claimed ownership of partition ${ownershipRequest.partitionId}.`\n      );\n\n      await this._startPump(ownershipRequest.partitionId, abortSignal);\n    } catch (err) {\n      logger.warning(\n        `[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`\n      );\n      logErrorStackTrace(err);\n      await this._handleSubscriptionError(err);\n    }\n  }\n\n  private async _startPump(partitionId: string, abortSignal: AbortSignalLike): Promise<void> {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] The subscription was closed before starting to read from ${partitionId}.`\n      );\n      return;\n    }\n\n    if (this._pumpManager.isReceivingFromPartition(partitionId)) {\n      logger.verbose(\n        `[${this._id}] There is already an active partitionPump for partition \"${partitionId}\", skipping pump creation.`\n      );\n      return;\n    }\n\n    logger.verbose(\n      `[${this._id}] [${partitionId}] Calling user-provided PartitionProcessorFactory.`\n    );\n\n    const partitionProcessor = new PartitionProcessor(\n      this._subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n        eventHubName: this._eventHubName,\n        consumerGroup: this._consumerGroup,\n        partitionId: partitionId,\n        eventProcessorId: this.id\n      }\n    );\n\n    const eventPosition = await this._getStartingPosition(partitionId);\n    await this._pumpManager.createPump(\n      eventPosition,\n      this._context,\n      partitionProcessor,\n      abortSignal\n    );\n\n    logger.verbose(`[${this._id}] PartitionPump created successfully.`);\n  }\n\n  private async _getStartingPosition(partitionIdToClaim: string): Promise<EventPosition> {\n    const availableCheckpoints = await this._checkpointStore.listCheckpoints(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n\n    const validCheckpoints = availableCheckpoints.filter(\n      (chk) => chk.partitionId === partitionIdToClaim\n    );\n\n    if (validCheckpoints.length > 0) {\n      return { offset: validCheckpoints[0].offset };\n    }\n\n    logger.verbose(\n      `No checkpoint found for partition ${partitionIdToClaim}. Looking for fallback.`\n    );\n    return getStartPosition(partitionIdToClaim, this._processorOptions.startPosition);\n  }\n\n  private async _runLoopForSinglePartition(\n    partitionId: string,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    while (!abortSignal.aborted) {\n      try {\n        await this._startPump(partitionId, abortSignal);\n      } catch (err) {\n        logger.warning(\n          `[${this._id}] An error occured within the EventProcessor loop: ${err?.name}: ${err?.message}`\n        );\n        logErrorStackTrace(err);\n        await this._handleSubscriptionError(err);\n      } finally {\n        // sleep for some time after which we can attempt to create a pump again.\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${this._loopIntervalInMs} ms.`\n        );\n        // swallow errors from delay since it's fine for delay to exit early\n        await delayWithoutThrow(this._loopIntervalInMs, abortSignal);\n      }\n    }\n    this._isRunning = false;\n  }\n\n  /**\n   * Every loop to this method will result in this EventProcessor owning at most one new partition.\n   *\n   * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active\n   * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,\n   * this algorithm converges gradually towards a steady state.\n   *\n   * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an\n   * EventHubConsumer for processing events from that partition.\n   */\n  private async _runLoopWithLoadBalancing(\n    loadBalancingStrategy: LoadBalancingStrategy,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    let cancelLoopResolver;\n    // This provides a mechanism for exiting the loop early\n    // if the subscription has had `close` called.\n    const cancelLoopPromise = new Promise<void>((resolve) => {\n      cancelLoopResolver = resolve;\n      if (abortSignal.aborted) {\n        resolve();\n        return;\n      }\n\n      abortSignal.addEventListener(\"abort\", resolve);\n    });\n\n    // Periodically check if any partitions need to be claimed and claim them.\n    while (!abortSignal.aborted) {\n      const iterationStartTimeInMs = Date.now();\n      try {\n        const { partitionIds } = await this._context.managementSession!.getEventHubProperties({\n          abortSignal: abortSignal\n        });\n        await this._performLoadBalancing(loadBalancingStrategy, partitionIds, abortSignal);\n      } catch (err) {\n        logger.warning(\n          `[${this._id}] An error occured within the EventProcessor loop: ${err?.name}: ${err?.message}`\n        );\n        logErrorStackTrace(err);\n        // Protect against the scenario where the user awaits on subscription.close() from inside processError.\n        await Promise.race([this._handleSubscriptionError(err), cancelLoopPromise]);\n      } finally {\n        // Sleep for some time, then continue the loop.\n        const iterationDeltaInMs = Date.now() - iterationStartTimeInMs;\n        const delayDurationInMs = Math.max(this._loopIntervalInMs - iterationDeltaInMs, 0);\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${delayDurationInMs} ms.`\n        );\n        // Swallow the error since it's fine to exit early from the delay.\n        await delayWithoutThrow(delayDurationInMs, abortSignal);\n      }\n    }\n\n    if (cancelLoopResolver) {\n      abortSignal.removeEventListener(\"abort\", cancelLoopResolver);\n    }\n    this._isRunning = false;\n  }\n\n  private async _performLoadBalancing(\n    loadBalancingStrategy: LoadBalancingStrategy,\n    partitionIds: string[],\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    if (abortSignal.aborted) throw new AbortError(\"The operation was aborted.\");\n\n    // Retrieve current partition ownership details from the datastore.\n    const partitionOwnership = await this._checkpointStore.listOwnership(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n\n    if (abortSignal.aborted) throw new AbortError(\"The operation was aborted.\");\n\n    const partitionOwnershipMap = new Map<string, PartitionOwnership>();\n    const nonAbandonedPartitionOwnershipMap = new Map<string, PartitionOwnership>();\n    const partitionsToRenew: string[] = [];\n\n    // Separate abandoned ownerships from claimed ownerships.\n    // We only want to pass active partition ownerships to the\n    // load balancer, but we need to hold onto the abandoned\n    // partition ownerships because we need the etag to claim them.\n    for (const ownership of partitionOwnership) {\n      partitionOwnershipMap.set(ownership.partitionId, ownership);\n      if (!isAbandoned(ownership)) {\n        nonAbandonedPartitionOwnershipMap.set(ownership.partitionId, ownership);\n      }\n      if (\n        ownership.ownerId === this._id &&\n        this._pumpManager.isReceivingFromPartition(ownership.partitionId)\n      ) {\n        partitionsToRenew.push(ownership.partitionId);\n      }\n    }\n\n    // Pass the list of all the partition ids and the collection of claimed partition ownerships\n    // to the load balance strategy.\n    // The load balancing strategy only needs to know the full list of partitions,\n    // and which of those are currently claimed.\n    // Since abandoned partitions are no longer claimed, we exclude them.\n    const partitionsToClaim = loadBalancingStrategy.getPartitionsToCliam(\n      this._id,\n      nonAbandonedPartitionOwnershipMap,\n      partitionIds\n    );\n    partitionsToClaim.push(...partitionsToRenew);\n\n    const uniquePartitionsToClaim = new Set(partitionsToClaim);\n    for (const partitionToClaim of uniquePartitionsToClaim) {\n      const partitionOwnershipRequest = this._createPartitionOwnershipRequest(\n        partitionOwnershipMap,\n        partitionToClaim\n      );\n\n      await this._claimOwnership(partitionOwnershipRequest, abortSignal);\n    }\n  }\n\n  /**\n   * This is called when there are errors that are not specific to a partition (ex: load balancing)\n   */\n  private async _handleSubscriptionError(err: Error): Promise<void> {\n    // filter out any internal \"expected\" errors\n    if (err.name === \"AbortError\") {\n      return;\n    }\n\n    if (this._subscriptionEventHandlers.processError) {\n      try {\n        await this._subscriptionEventHandlers.processError(err, {\n          fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n          eventHubName: this._eventHubName,\n          consumerGroup: this._consumerGroup,\n          partitionId: \"\",\n          updateCheckpoint: async () => {\n            /* no-op */\n          }\n        });\n      } catch (errorFromUser) {\n        logger.verbose(\n          `[${this._id}] An error was thrown from the user's processError handler: ${errorFromUser}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the\n   * same consumer group, the partitions are distributed among these instances to process events.\n   *\n   * For each partition, the user provided `PartitionProcessor` is instantiated.\n   *\n   * Subsequent calls to start will be ignored if this event processor is already running.\n   * Calling `start()` after `stop()` is called will restart this event processor.\n   *\n   */\n  start(): void {\n    if (this._isRunning) {\n      logger.verbose(`[${this._id}] Attempted to start an already running EventProcessor.`);\n      return;\n    }\n\n    this._isRunning = true;\n    this._abortController = new AbortController();\n    logger.verbose(`[${this._id}] Starting an EventProcessor.`);\n\n    if (this._processingTarget) {\n      logger.verbose(`[${this._id}] Single partition target: ${this._processingTarget}`);\n      this._loopTask = this._runLoopForSinglePartition(\n        this._processingTarget,\n        this._abortController.signal\n      );\n    } else {\n      logger.verbose(`[${this._id}] Multiple partitions, using load balancer`);\n      this._loopTask = this._runLoopWithLoadBalancing(\n        this._loadBalancingStrategy,\n        this._abortController.signal\n      );\n    }\n  }\n\n  isRunning(): boolean {\n    return this._isRunning;\n  }\n\n  /**\n   * Stops processing events for all partitions owned by this event processor.\n   * All `PartitionProcessor` will be shutdown and any open resources will be closed.\n   *\n   * Subsequent calls to stop will be ignored if the event processor is not running.\n   *\n   */\n  async stop(): Promise<void> {\n    logger.verbose(`[${this._id}] Stopping an EventProcessor.`);\n    if (this._abortController) {\n      // cancel the event processor loop\n      this._abortController.abort();\n    }\n\n    try {\n      // remove all existing pumps\n      await this._pumpManager.removeAllPumps(CloseReason.Shutdown);\n\n      // waits for the event processor loop to complete\n      // will complete immediately if _loopTask is undefined\n      if (this._loopTask) {\n        await this._loopTask;\n      }\n    } catch (err) {\n      logger.verbose(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);\n    } finally {\n      logger.verbose(`[${this._id}] EventProcessor stopped.`);\n    }\n\n    if (this._processingTarget) {\n      logger.verbose(`[${this._id}] No partitions owned, skipping abandoning.`);\n    } else {\n      await this.abandonPartitionOwnerships();\n    }\n  }\n\n  private async abandonPartitionOwnerships(): Promise<PartitionOwnership[]> {\n    logger.verbose(`[${this._id}] Abandoning owned partitions`);\n    const allOwnerships = await this._checkpointStore.listOwnership(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n    const ourOwnerships = allOwnerships.filter((ownership) => ownership.ownerId === this._id);\n    // unclaim any partitions that we currently own\n    for (const ownership of ourOwnerships) {\n      ownership.ownerId = \"\";\n    }\n    return this._checkpointStore.claimOwnership(ourOwnerships);\n  }\n}\n\nfunction isAbandoned(ownership: PartitionOwnership): boolean {\n  return ownership.ownerId === \"\";\n}\n\nfunction getStartPosition(\n  partitionIdToClaim: string,\n  startPositions?: EventPosition | { [partitionId: string]: EventPosition }\n): EventPosition {\n  if (startPositions == null) {\n    return latestEventPosition;\n  }\n\n  if (isEventPosition(startPositions)) {\n    return startPositions;\n  }\n\n  const startPosition = (startPositions as { [partitionId: string]: EventPosition })[\n    partitionIdToClaim\n  ];\n\n  if (startPosition == null) {\n    return latestEventPosition;\n  }\n\n  return startPosition;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Used by EventHubConsumerClient to prevent accidentally spinning up multiple\n * subscriptions against the same set of partitions.\n *\n * This is needed now that EventHubConsumerClient only uses a single CheckpointStore\n * instance - otherwise users will see unpredictable results as their event processor\n * continually steals/overwrites checkpointing and ownership with itself.\n *\n * @internal\n */\nexport class PartitionGate {\n  private _partitions = new Set<string>();\n\n  /**\n   * Adds a partition, throwing an Error if there is a conflict with partitions (including \"all\")\n   * that are already added.\n   *\n   * @param partitionId - A partition ID or the constant \"all\"\n   */\n  add(partitionId: string | \"all\"): void {\n    if (\n      (partitionId === \"all\" && this._partitions.size > 0) ||\n      this._partitions.has(partitionId) ||\n      this._partitions.has(\"all\")\n    ) {\n      throw new Error(`Partition already has a subscriber.`);\n    }\n\n    this._partitions.add(partitionId);\n  }\n\n  /**\n   * Removes a partition\n   *\n   * @param partitionId - A partition ID or the constant \"all\"\n   */\n  remove(partitionId: string | \"all\"): void {\n    this._partitions.delete(partitionId);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { LoadBalancingStrategy } from \"./loadBalancingStrategy\";\n\n/**\n * The UnbalancedLoadBalancingStrategy does no actual load balancing.\n * It is intended to be used when you want to avoid load balancing\n * and consume a set of partitions.\n * @internal\n */\nexport class UnbalancedLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param _ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param _claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToCliam(\n    _ourOwnerId: string,\n    _claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    return partitionIds;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { logger } from \"../log\";\n\n/**\n * Determines which partitions to claim as part of load balancing.\n * @internal\n */\nexport interface LoadBalancingStrategy {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  getPartitionsToCliam(\n    ownerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[];\n}\n\n/**\n * Counts of the EventProcessors that currently own partitions.\n * @internal\n */\ninterface EventProcessorCounts {\n  /**\n   * The # of EventProcessors that only own the required # of\n   * partitions.\n   */\n  haveRequiredPartitions: number;\n  /**\n   * The # of EventProcessors that currently own the required #\n   * of partitions + 1 additional (ie, handling the case where\n   * the number of partitions is not evenly divisible by the # of\n   * EventProcessors).\n   */\n  haveAdditionalPartition: number;\n  /**\n   * EventProcessors which have more than the required or even required + 1\n   * number of partitions. These will eventually be downsized by other\n   * EventProcessors as they acquire their required number of partitions.\n   */\n  haveTooManyPartitions: number;\n}\n\n/**\n * This method will create a new map of partition id and PartitionOwnership containing only those partitions\n * that are actively owned.\n * All entries in the original map that haven't been modified for a duration of time greater than the allowed\n * inactivity time limit are assumed to be owned by dead event processors.\n * These will not be included in the map returned by this method.\n *\n * @param partitionOwnershipMap - The existing PartitionOwnerships mapped by partition.\n * @param expirationIntervalInMs - The length of time a PartitionOwnership claim is valid.\n * @hidden\n */\nfunction getActivePartitionOwnerships(\n  partitionOwnershipMap: Map<string, PartitionOwnership>,\n  expirationIntervalInMs: number\n): Map<string, PartitionOwnership> {\n  const activePartitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  partitionOwnershipMap.forEach((partitionOwnership: PartitionOwnership, partitionId: string) => {\n    // If lastModifiedtimeInMs is missing, assume it is inactive.\n    if (\n      typeof partitionOwnership.lastModifiedTimeInMs === \"undefined\" ||\n      partitionOwnership.lastModifiedTimeInMs === null\n    ) {\n      return;\n    }\n\n    const timeSincePartitionClaimed = Date.now() - partitionOwnership.lastModifiedTimeInMs;\n    if (timeSincePartitionClaimed < expirationIntervalInMs && partitionOwnership.ownerId) {\n      activePartitionOwnershipMap.set(partitionId, partitionOwnership);\n    }\n  });\n\n  return activePartitionOwnershipMap;\n}\n\n/**\n * Calculates the minimum number of partitions each EventProcessor should own,\n * and the number of EventProcessors that should have an extra partition assigned.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @param partitionIds - The full list of the Event Hub's partition ids.\n * @internal\n */\nfunction calculateBalancedLoadCounts(\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>,\n  partitionIds: string[]\n): { minPartitionsPerOwner: number; requiredNumberOfOwnersWithExtraPartition: number } {\n  // Calculate the minimum number of partitions every EventProcessor should own when the load\n  // is evenly distributed.\n  const minPartitionsPerOwner = Math.floor(partitionIds.length / ownerToOwnershipMap.size);\n\n  // If the number of partitions in the Event Hub is not evenly divisible by the number of active\n  // EventProcesrrors, some EventProcessors may own 1 partition in addition to the minimum when the\n  // load is balanced.\n  // Calculate the number of EventProcessors that can own an additional partition.\n  const requiredNumberOfOwnersWithExtraPartition = partitionIds.length % ownerToOwnershipMap.size;\n\n  return {\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition\n  };\n}\n\n/**\n * Counts the EventProcessors and tallies them by type.\n *\n * To be in balance we need to make sure that each EventProcessor is only consuming\n * their fair share.\n *\n * When the partitions are divvied up we will sometimes end up with some EventProcessors\n * that will have 1 more partition than others.\n * This can happen if the number of partitions is not evenly divisible by the number of EventProcessors.\n *\n * So this function largely exists to support isLoadBalanced() and\n * shouldOwnMorePartitions(), both of which depend on knowing if our current list\n * of EventProcessors is actually in the proper state.\n *\n * @param minPartitionsPerOwner - The number of required partitions per EventProcessor.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction getEventProcessorCounts(\n  minPartitionsPerOwner: number,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>\n): EventProcessorCounts {\n  const counts: EventProcessorCounts = {\n    haveRequiredPartitions: 0,\n    haveAdditionalPartition: 0,\n    haveTooManyPartitions: 0\n  };\n\n  for (const ownershipList of ownerToOwnershipMap.values()) {\n    const numberOfPartitions = ownershipList.length;\n\n    // there are basically three kinds of partition counts\n    // for a processor:\n\n    if (numberOfPartitions === minPartitionsPerOwner) {\n      // 1. Has _exactly_ the required number of partitions\n      counts.haveRequiredPartitions++;\n    } else if (numberOfPartitions === minPartitionsPerOwner + 1) {\n      // 2. Has the required number plus one extra (correct in cases)\n      // where the # of partitions is not evenly divisible by the\n      // number of processors.\n      counts.haveAdditionalPartition++;\n    } else if (numberOfPartitions > minPartitionsPerOwner + 1) {\n      // 3. has more than the possible # of partitions required\n      counts.haveTooManyPartitions++;\n    }\n  }\n\n  return counts;\n}\n\n/**\n * Validates that we are currently in a balanced state - all EventProcessors own the\n * minimum required number of partitions (and additional partitions, if the # of partitions\n * is not evenly divisible by the # of EventProcessors).\n *\n * @param requiredNumberOfOwnersWithExtraPartition - The # of EventProcessors that process an additional partition, in addition to the required minimum.\n * @param totalExpectedProcessors - The total # of EventProcessors we expect.\n * @param eventProcessorCounts - EventProcessor counts, grouped by criteria.\n * @internal\n */\nfunction isLoadBalanced(\n  requiredNumberOfOwnersWithExtraPartition: number,\n  totalExpectedEventProcessors: number,\n  { haveAdditionalPartition, haveRequiredPartitions }: EventProcessorCounts\n): boolean {\n  return (\n    haveAdditionalPartition === requiredNumberOfOwnersWithExtraPartition &&\n    haveRequiredPartitions + haveAdditionalPartition === totalExpectedEventProcessors\n  );\n}\n\n/**\n * Determines the number of new partitions to claim for this particular processor.\n *\n * @param minRequired - The minimum required number of partitions.\n * @param requiredNumberOfOwnersWithExtraPartition - The current number of processors that should have an additional partition.\n * @param numPartitionsOwnedByUs - The number of partitions we currently own.\n * @param eventProcessorCounts - Processors, grouped by criteria.\n * @internal\n */\nfunction getNumberOfPartitionsToClaim(\n  minRequiredPartitionCount: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  numPartitionsOwnedByUs: number,\n  { haveAdditionalPartition, haveTooManyPartitions }: EventProcessorCounts\n): number {\n  let actualRequiredPartitionCount = minRequiredPartitionCount;\n\n  if (\n    requiredNumberOfOwnersWithExtraPartition > 0 &&\n    // Eventually the `haveTooManyPartitions` will decay into `haveAdditionalPartition`\n    // EventProcessors as partitions are balanced to consumers that aren't at par.\n    // We can consider them to be `haveAdditionalPartition` EventProcessors for our purposes.\n    haveAdditionalPartition + haveTooManyPartitions < requiredNumberOfOwnersWithExtraPartition\n  ) {\n    // Overall we don't have enough EventProcessors that are taking on an additional partition\n    // so we should attempt to.\n    actualRequiredPartitionCount = minRequiredPartitionCount + 1;\n  }\n  return actualRequiredPartitionCount - numPartitionsOwnedByUs;\n}\n\n/**\n * Determines which partitions can be stolen from other owners while maintaining\n * a balanced state.\n * @param numberOfPartitionsToClaim - The number of partitions the owner needs to claim to reach a balanced state.\n * @param minPartitionsPerOwner - The minimum number of partitions each owner needs for the partition load to be balanced.\n * @param requiredNumberOfOwnersWithExtraPartition - The number of owners that should have 1 extra partition.\n * @param ourOwnerId - The id of _our_ owner.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction findPartitionsToSteal(\n  numberOfPartitionsToClaim: number,\n  minPartitionsPerOwner: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  ourOwnerId: string,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>\n): string[] {\n  const partitionsToSteal: string[] = [];\n  // Create a list of PartitionOwnership lists that we can steal from.\n  const listOfPartitionOwnerships: Array<PartitionOwnership[]> = [];\n  ownerToOwnershipMap.forEach((partitionOwnerships, ownerId) => {\n    if (ownerId === ourOwnerId || partitionOwnerships.length <= minPartitionsPerOwner) return;\n    listOfPartitionOwnerships.push(partitionOwnerships);\n  });\n\n  // Sort the list in descending order based on the length of each element.\n  listOfPartitionOwnerships.sort((a, b) => {\n    if (a.length > b.length) return -1;\n    if (a.length < b.length) return 1;\n    return 0;\n  });\n\n  // Attempt to steal partitions from EventProcessors that have the most partitions 1st,\n  // then work our way down.\n  let ownersEncounteredWithExtraPartitions = 0;\n  let currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  while (numberOfPartitionsToClaim > 0 && currentPartitionOwnershipList) {\n    let ownersExpectedPartitionCount = minPartitionsPerOwner;\n    // Determine if the current owner should be allowed to have an extra partition.\n    if (ownersEncounteredWithExtraPartitions < requiredNumberOfOwnersWithExtraPartition) {\n      ownersExpectedPartitionCount++;\n    }\n    ownersEncounteredWithExtraPartitions++;\n\n    let numberAvailableToSteal =\n      currentPartitionOwnershipList.length - ownersExpectedPartitionCount;\n    // Claim as many random partitions as possible.\n    while (Math.min(numberOfPartitionsToClaim, numberAvailableToSteal)) {\n      const indexToClaim = Math.floor(Math.random() * currentPartitionOwnershipList.length);\n      partitionsToSteal.push(currentPartitionOwnershipList.splice(indexToClaim, 1)[0].partitionId);\n      numberOfPartitionsToClaim--;\n      numberAvailableToSteal--;\n    }\n\n    // Move on to the next list of PartitionOwnership.\n    currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  }\n\n  return partitionsToSteal;\n}\n\n/**\n * Identifies all of the partitions that can be claimed by the specified owner for\n * that owner to reach a balanced state.\n * @param OwnerId - The id we should assume is _our_ id when checking for ownership.\n * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n * @param partitionIds - Partitions to assign owners to.\n * @param expirationIntervalInMs - The length of time a partition claim is valid.\n * @returns Partition ids that may be claimed.\n * @internal\n */\nexport function listAvailablePartitions(\n  ownerId: string,\n  claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n  partitionIds: string[],\n  expirationIntervalInMs: number\n): string[] {\n  if (!partitionIds.length) {\n    return [];\n  }\n\n  // Collect only the PartitionOwnership that have been updated within the expiration interval.\n  // Any PartitionOwnership that has been updated outside the expiration interval can be claimed.\n  const activePartitionOwnershipMap = getActivePartitionOwnerships(\n    claimedPartitionOwnershipMap,\n    expirationIntervalInMs\n  );\n  logger.verbose(\n    `[${ownerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`\n  );\n\n  if (activePartitionOwnershipMap.size === 0) {\n    // All partitions in this Event Hub are available to claim.\n    return partitionIds;\n  }\n\n  // Map ownerIds to the partitions they own so that we can determine how many each owner has.\n  const ownerToOwnershipMap = new Map<string, PartitionOwnership[]>();\n  for (const activeOwnership of activePartitionOwnershipMap.values()) {\n    const partitionOwnershipList = ownerToOwnershipMap.get(activeOwnership.ownerId) || [];\n\n    partitionOwnershipList.push(activeOwnership);\n    ownerToOwnershipMap.set(activeOwnership.ownerId, partitionOwnershipList);\n  }\n\n  // Add the current EventProcessor to the map of owners to ownerships if it doesn't exist.\n  if (!ownerToOwnershipMap.has(ownerId)) {\n    ownerToOwnershipMap.set(ownerId, []);\n  }\n\n  logger.info(`[${ownerId}] Number of active event processors: ${ownerToOwnershipMap.size}.`);\n\n  const {\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition\n  } = calculateBalancedLoadCounts(ownerToOwnershipMap, partitionIds);\n\n  logger.verbose(\n    `[${ownerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerOwner},` +\n      `expected number of event processors with additional partition: ${requiredNumberOfOwnersWithExtraPartition}.`\n  );\n\n  // Get some stats representing the current state the world with regards to how balanced the\n  // partitions are across EventProcessors.\n  const eventProcessorCounts = getEventProcessorCounts(minPartitionsPerOwner, ownerToOwnershipMap);\n\n  if (\n    isLoadBalanced(\n      requiredNumberOfOwnersWithExtraPartition,\n      ownerToOwnershipMap.size,\n      eventProcessorCounts\n    )\n  ) {\n    // When the partitions are evenly distributed, no change required.\n    return [];\n  }\n\n  let numberOfPartitionsToClaim = getNumberOfPartitionsToClaim(\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerToOwnershipMap.get(ownerId)!.length,\n    eventProcessorCounts\n  );\n\n  if (numberOfPartitionsToClaim <= 0) {\n    return [];\n  }\n\n  const partitionsToClaim: string[] = [];\n  const unclaimedPartitionIds = partitionIds.filter((id) => !activePartitionOwnershipMap.has(id));\n\n  // Prioritize getting unclaimed partitions first.\n  while (Math.min(numberOfPartitionsToClaim, unclaimedPartitionIds.length)) {\n    const indexToClaim = Math.floor(Math.random() * unclaimedPartitionIds.length);\n    partitionsToClaim.push(unclaimedPartitionIds.splice(indexToClaim, 1)[0]);\n    numberOfPartitionsToClaim--;\n  }\n\n  if (numberOfPartitionsToClaim === 0) {\n    return partitionsToClaim;\n  }\n\n  // Find partitions that can be stolen from other EventProcessors.\n  const partitionsToSteal = findPartitionsToSteal(\n    numberOfPartitionsToClaim,\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerId,\n    ownerToOwnershipMap\n  );\n\n  return partitionsToClaim.concat(partitionsToSteal);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { LoadBalancingStrategy, listAvailablePartitions } from \"./loadBalancingStrategy\";\n\n/**\n * @internal\n */\nexport class GreedyLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Creates an instance of GreedyLoadBalancingStrategy.\n   *\n   * @param _partitionOwnershipExpirationIntervalInMs - The length of time a partition claim is valid.\n   */\n  constructor(private readonly _partitionOwnershipExpirationIntervalInMs: number) {}\n\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the new set of partitions to add.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToCliam(\n    ourOwnerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    return listAvailablePartitions(\n      ourOwnerId,\n      claimedPartitionOwnershipMap,\n      partitionIds,\n      this._partitionOwnershipExpirationIntervalInMs\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { LoadBalancingStrategy, listAvailablePartitions } from \"./loadBalancingStrategy\";\n\n/**\n * The BalancedLoadBalancerStrategy is meant to be used when the user\n * wants to reach a load balanced state with less partition 'thrashing'.\n *\n * Partition thrashing - where a partition changes owners - is minimized\n * by only returning a single partition to claim at a time.\n * This minimizes the number of times a partition should need to be stolen.\n * @internal\n */\nexport class BalancedLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Creates an instance of BalancedLoadBalancingStrategy.\n   *\n   * @param _partitionOwnershipExpirationIntervalInMs - The length of time a partition claim is valid.\n   */\n  constructor(private readonly _partitionOwnershipExpirationIntervalInMs: number) {}\n\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToCliam(\n    ourOwnerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    const claimablePartitions = listAvailablePartitions(\n      ourOwnerId,\n      claimedPartitionOwnershipMap,\n      partitionIds,\n      this._partitionOwnershipExpirationIntervalInMs\n    );\n\n    if (!claimablePartitions.length) {\n      return [];\n    }\n\n    const randomIndex = Math.floor(Math.random() * claimablePartitions.length);\n    return [claimablePartitions[randomIndex]];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext, createConnectionContext } from \"./connectionContext\";\nimport {\n  EventHubConsumerClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  LoadBalancingOptions\n} from \"./models/public\";\nimport { InMemoryCheckpointStore } from \"./inMemoryCheckpointStore\";\nimport { CheckpointStore, EventProcessor, FullEventProcessorOptions } from \"./eventProcessor\";\nimport { Constants } from \"@azure/core-amqp\";\nimport { logger } from \"./log\";\n\nimport {\n  SubscribeOptions,\n  Subscription,\n  SubscriptionEventHandlers\n} from \"./eventHubConsumerClientModels\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport { PartitionGate } from \"./impl/partitionGate\";\nimport { v4 as uuid } from \"uuid\";\nimport { validateEventPositions } from \"./eventPosition\";\nimport { LoadBalancingStrategy } from \"./loadBalancerStrategies/loadBalancingStrategy\";\nimport { UnbalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/unbalancedStrategy\";\nimport { GreedyLoadBalancingStrategy } from \"./loadBalancerStrategies/greedyStrategy\";\nimport { BalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/balancedStrategy\";\n\nconst defaultConsumerClientOptions: Required<Pick<\n  FullEventProcessorOptions,\n  \"maxWaitTimeInSeconds\" | \"maxBatchSize\"\n>> = {\n  // to support our current \"process single event only\" workflow we'll also purposefully\n  // only request a single event at a time.\n  maxBatchSize: 1,\n  maxWaitTimeInSeconds: 60\n};\n\n/**\n * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n *\n * There are multiple ways to create an `EventHubConsumerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass:\n * - An options bag to configure the retry policy or proxy settings.\n * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should\n * resume receiving events when your application gets restarted. The checkpoint store is also used by the client\n * to load balance multiple instances of your application.\n */\nexport class EventHubConsumerClient {\n  /**\n   * Describes the amqp connection context for the client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubConsumerClientOptions;\n  private _partitionGate = new PartitionGate();\n  private _id = uuid();\n\n  /**\n   * The Subscriptions that were spawned by calling `subscribe()`.\n   * Subscriptions that have been stopped by the user will not\n   * be present in this set.\n   */\n  private _subscriptions = new Set<Subscription>();\n\n  /**\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n\n  private _checkpointStore: CheckpointStore;\n  private _userChoseCheckpointStore: boolean;\n\n  /**\n   * Options for configuring load balancing.\n   */\n  private readonly _loadBalancingOptions: Required<LoadBalancingOptions>;\n\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    options?: EventHubConsumerClientOptions\n  ); // #1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #1.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    options?: EventHubConsumerClientOptions\n  ); // #2\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #2.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    options?: EventHubConsumerClientOptions\n  ); // #3\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #3.1\n  constructor(\n    private _consumerGroup: string,\n    connectionStringOrFullyQualifiedNamespace2: string,\n    checkpointStoreOrEventHubNameOrOptions3?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | string,\n    checkpointStoreOrCredentialOrOptions4?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | TokenCredential,\n    checkpointStoreOrOptions5?: CheckpointStore | EventHubConsumerClientOptions,\n    options6?: EventHubConsumerClientOptions\n  ) {\n    if (isTokenCredential(checkpointStoreOrCredentialOrOptions4)) {\n      // #3 or 3.1\n      logger.info(\"Creating EventHubConsumerClient with TokenCredential.\");\n\n      if (isCheckpointStore(checkpointStoreOrOptions5)) {\n        // 3.1\n        this._checkpointStore = checkpointStoreOrOptions5;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = options6 || {};\n      } else {\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrOptions5 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3 as string,\n        checkpointStoreOrCredentialOrOptions4,\n        this._clientOptions\n      );\n    } else if (typeof checkpointStoreOrEventHubNameOrOptions3 === \"string\") {\n      // #2 or 2.1\n      logger.info(\"Creating EventHubConsumerClient with connection string and event hub name.\");\n\n      if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {\n        // 2.1\n        this._checkpointStore = checkpointStoreOrCredentialOrOptions4;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = (checkpointStoreOrOptions5 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 2\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrCredentialOrOptions4 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3,\n        this._clientOptions\n      );\n    } else {\n      // #1 or 1.1\n      logger.info(\"Creating EventHubConsumerClient with connection string.\");\n\n      if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {\n        // 1.1\n        this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions =\n          (checkpointStoreOrCredentialOrOptions4 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 1\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions =\n          (checkpointStoreOrEventHubNameOrOptions3 as EventHubConsumerClientOptions) || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        this._clientOptions\n      );\n    }\n    this._loadBalancingOptions = {\n      // default options\n      strategy: \"balanced\",\n      updateIntervalInMs: 10000,\n      partitionOwnershipExpirationIntervalInMs: 60000,\n      // options supplied by user\n      ...this._clientOptions?.loadBalancingOptions\n    };\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    // Stop all the actively running subscriptions.\n    const activeSubscriptions = Array.from(this._subscriptions);\n    await Promise.all(\n      activeSubscriptions.map((subscription) => {\n        return subscription.close();\n      })\n    );\n    // Close the connection via the connection context.\n    return this._context.close();\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._context\n      .managementSession!.getEventHubProperties({\n        ...options,\n        retryOptions: this._clientOptions.retryOptions\n      })\n      .then((eventHubProperties) => {\n        return eventHubProperties.partitionIds;\n      });\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._context.managementSession!.getPartitionProperties(partitionId, {\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._context.managementSession!.getEventHubProperties({\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  /**\n   * Subscribe to events from all partitions.\n   *\n   * If checkpoint store is provided to the `EventHubConsumerClient` and there are multiple\n   * instances of your application, then each instance will subscribe to a subset of the\n   * partitions such that the load is balanced amongst them.\n   *\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubConsumerClient(consumerGroup, connectionString, eventHubName);\n   * const subscription = client.subscribe(\n   *  {\n   *    processEvents: (events, context) => { console.log(\"Received event count: \", events.length) },\n   *    processError: (err, context) => { console.log(\"Error: \", err) }\n   *  },\n   *  { startPosition: earliestEventPosition }\n   * );\n   * ```\n   *\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 per partition, receiving events, handling errors and the closing\n   *                 of a subscription per partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }\n   */\n  subscribe(handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription; // #1\n  /**\n   * Subscribe to events from a single partition.\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubConsumerClient(consumerGroup, connectionString, eventHubName);\n   * const subscription = client.subscribe(\n   *  partitionId,\n   *  {\n   *    processEvents: (events, context) => { console.log(\"Received event count: \", events.length) },\n   *    processError: (err, context) => { console.log(\"Error: \", err) }\n   *  },\n   *  { startPosition: earliestEventPosition }\n   * );\n   * ```\n   *\n   * @param partitionId - The id of the partition to subscribe to.\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 of the partition, receiving events, handling errors and the closing\n   *                 of a subscription to the partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }\n   */\n\n  subscribe(\n    partitionId: string,\n    handlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): Subscription; // #2\n  subscribe(\n    handlersOrPartitionId1?: SubscriptionEventHandlers | string,\n    optionsOrHandlers2?: SubscribeOptions | SubscriptionEventHandlers,\n    possibleOptions3?: SubscribeOptions\n  ): Subscription {\n    let eventProcessor: EventProcessor;\n    let targetedPartitionId: string;\n\n    if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {\n      // #1: subscribe overload - read from all partitions\n      const options = optionsOrHandlers2 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(\n        handlersOrPartitionId1,\n        options\n      ));\n    } else if (isSubscriptionEventHandlers(optionsOrHandlers2)) {\n      // #2: subscribe overload (read from specific partition IDs), don't coordinate\n      const options = possibleOptions3 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(\n        // cast to string as downstream code expects partitionId to be string, but JS users could have given us anything.\n        // we don't validate the user input and instead rely on service throwing errors if any\n        String(handlersOrPartitionId1),\n        optionsOrHandlers2,\n        possibleOptions3\n      ));\n    } else {\n      throw new TypeError(\"Unhandled subscribe() overload\");\n    }\n\n    eventProcessor.start();\n\n    const subscription = {\n      get isRunning() {\n        return eventProcessor.isRunning();\n      },\n      close: () => {\n        this._partitionGate.remove(targetedPartitionId);\n        this._subscriptions.delete(subscription);\n        return eventProcessor.stop();\n      }\n    };\n    this._subscriptions.add(subscription);\n    return subscription;\n  }\n\n  /**\n   * Gets the LoadBalancing strategy that should be used based on what the user provided.\n   */\n  private _getLoadBalancingStrategy(): LoadBalancingStrategy {\n    if (!this._userChoseCheckpointStore) {\n      // The default behavior when a checkpointstore isn't provided\n      // is to always grab all the partitions.\n      return new UnbalancedLoadBalancingStrategy();\n    }\n\n    const partitionOwnershipExpirationIntervalInMs = this._loadBalancingOptions\n      .partitionOwnershipExpirationIntervalInMs;\n    if (this._loadBalancingOptions?.strategy === \"greedy\") {\n      return new GreedyLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n    }\n\n    // The default behavior when a checkpointstore is provided is\n    // to grab one partition at a time.\n    return new BalancedLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n  }\n\n  private createEventProcessorForAllPartitions(\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(\"all\");\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        \"EventHubConsumerClient subscribing to all partitions, using a checkpoint store.\"\n      );\n    } else {\n      logger.verbose(\"EventHubConsumerClient subscribing to all partitions, no checkpoint store.\");\n    }\n\n    const loadBalancingStrategy = this._getLoadBalancingStrategy();\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...(options as SubscribeOptions),\n        ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore),\n        // make it so all the event processors process work with the same overarching owner ID\n        // this allows the EventHubConsumer to unify all the work for any processors that it spawns\n        ownerId: this._id,\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy,\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs\n      }\n    );\n\n    return { targetedPartitionId: \"all\", eventProcessor };\n  }\n\n  private createEventProcessorForSinglePartition(\n    partitionId: string,\n    eventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(partitionId);\n\n    const subscribeOptions = options as SubscribeOptions | undefined;\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`\n      );\n    } else {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`\n      );\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      eventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...options,\n        processingTarget: partitionId,\n        ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore),\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy: new UnbalancedLoadBalancingStrategy(),\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs ?? 10000\n      }\n    );\n\n    return { targetedPartitionId: partitionId, eventProcessor };\n  }\n\n  private _createEventProcessor(\n    connectionContext: ConnectionContext,\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ): EventProcessor {\n    return new EventProcessor(\n      this._consumerGroup,\n      connectionContext,\n      subscriptionEventHandlers,\n      checkpointStore,\n      options\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport function isCheckpointStore(possible: CheckpointStore | any): possible is CheckpointStore {\n  if (!possible) {\n    return false;\n  }\n\n  const checkpointStore = possible as CheckpointStore;\n\n  return (\n    typeof checkpointStore.claimOwnership === \"function\" &&\n    typeof checkpointStore.listCheckpoints === \"function\" &&\n    typeof checkpointStore.listOwnership === \"function\" &&\n    typeof checkpointStore.updateCheckpoint === \"function\"\n  );\n}\n\n/**\n * @internal\n */\nfunction isSubscriptionEventHandlers(\n  possible: any | SubscriptionEventHandlers\n): possible is SubscriptionEventHandlers {\n  return typeof (possible as SubscriptionEventHandlers).processEvents === \"function\";\n}\n\nfunction getOwnerLevel(\n  options: SubscribeOptions | undefined,\n  userChoseCheckpointStore: boolean\n): number | undefined {\n  if (options && options.ownerLevel) {\n    return options.ownerLevel;\n  }\n\n  if (userChoseCheckpointStore) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { getTracer } from \"@azure/core-tracing\";\nimport { Span, SpanContext, SpanKind } from \"@opentelemetry/api\";\nimport { EventHubConnectionConfig } from \"../eventhubConnectionConfig\";\n\n/**\n * @internal\n */\nexport function createMessageSpan(\n  parentSpan?: Span | SpanContext | null,\n  eventHubConfig?: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">\n): Span {\n  const tracer = getTracer();\n  const span = tracer.startSpan(\"Azure.EventHubs.message\", {\n    kind: SpanKind.PRODUCER,\n    parent: parentSpan\n  });\n  span.setAttribute(\"az.namespace\", \"Microsoft.EventHub\");\n  if (eventHubConfig) {\n    span.setAttribute(\"message_bus.destination\", eventHubConfig.entityPath);\n    span.setAttribute(\"peer.address\", eventHubConfig.host);\n  }\n\n  return span;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventData, toRheaMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { MessageAnnotations, message, Message as RheaMessage } from \"rhea-promise\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { Span, SpanContext } from \"@opentelemetry/api\";\nimport { TRACEPARENT_PROPERTY, instrumentEventData } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\nimport { isDefined, isObjectWithProperties } from \"./util/typeGuards\";\n\n/**\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch - The instance of `EventDataBatch` to verify.\n * @internal\n */\nexport function isEventDataBatch(eventDataBatch: unknown): eventDataBatch is EventDataBatch {\n  return (\n    isObjectWithProperties(eventDataBatch, [\"count\", \"sizeInBytes\", \"tryAdd\"]) &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * Options to configure the behavior of the `tryAdd` method on the `EventDataBatch` class.\n */\nexport interface TryAddOptions {\n  /**\n   * The `Span` or `SpanContext` to use as the `parent` of any spans created while adding events.\n   */\n  parentSpan?: Span | SpanContext;\n}\n\n/**\n * An interface representing a batch of events which can be used to send events to Event Hub.\n *\n * To create the batch, use the `createBatch()` method on the `EventHubProducerClient`.\n * To send the batch, use the `sendBatch()` method on the same client.\n * To fill the batch, use the `tryAdd()` method on the batch itself.\n *\n */\nexport interface EventDataBatch {\n  /**\n   * A value that is hashed and used by the Azure Event Hubs service to determine the partition to\n   * which the events are sent. Use the `createBatch()` method on the `EventHubProducerClient` to\n   * set the partitionKey.\n   * @readonly\n   * @internal\n   */\n  readonly partitionKey?: string;\n\n  /**\n   * Id of the partition to which the batch of events are sent. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the partitionId.\n   * @readonly\n   * @internal\n   */\n  readonly partitionId?: string;\n\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of events added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAdd` function on the batch will return `false`\n   * if the event being added causes the size of the batch to exceed this limit. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the maxSizeInBytes.\n   * @readonly.\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds an event to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  tryAdd(eventData: EventData, options?: TryAddOptions): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `EventHubProducerClient`.\n   * This is not meant for the user to use directly.\n   *\n   * @internal\n   */\n  _generateMessage(): Buffer;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   */\n  readonly _messageSpanContexts: SpanContext[];\n}\n\n/**\n * An internal class representing a batch of events which can be used to send events to Event Hub.\n *\n * @internal\n */\nexport class EventDataBatchImpl implements EventDataBatch {\n  /**\n   * Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The Id of the partition to which the batch is expected to be sent to.\n   * Specifying this will throw an error if the batch was created using a `paritionKey`.\n   */\n  private _partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the batch was created using a `paritionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * The maximum size allowed for the batch.\n   */\n  private _maxSizeInBytes: number;\n  /**\n   * Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: SpanContext[] = [];\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first event\n   * that was added to the batch.\n   * A common annotation is the partition key.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @internal\n   */\n  constructor(\n    context: ConnectionContext,\n    maxSizeInBytes: number,\n    partitionKey?: string,\n    partitionId?: string\n  ) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._partitionKey = isDefined(partitionKey) ? String(partitionKey) : partitionKey;\n    this._partitionId = isDefined(partitionId) ? String(partitionId) : partitionId;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * The partitionId set during `EventDataBatch` creation.\n   * If this value is set then partitionKey can not be set.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._partitionId;\n  }\n\n  /**\n   * Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   */\n  get _messageSpanContexts(): SpanContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded events and annotations.\n   * @param encodedEvents - The already encoded events to include in the AMQP batch.\n   * @param annotations - The message annotations to set on the batch.\n   */\n  private _generateBatch(encodedEvents: Buffer[], annotations?: MessageAnnotations): Buffer {\n    const batchEnvelope: RheaMessage = {\n      body: message.data_sections(encodedEvents)\n    };\n    if (annotations) {\n      batchEnvelope.message_annotations = annotations;\n    }\n    return message.encode(batchEnvelope);\n  }\n\n  /**\n   * Generates the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(): Buffer {\n    return this._generateBatch(this._encodedMessages, this._batchAnnotations);\n  }\n\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"tryAdd\", \"eventData\", eventData);\n\n    // check if the event has already been instrumented\n    const previouslyInstrumented = Boolean(\n      eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]\n    );\n    let spanContext: SpanContext | undefined;\n    if (!previouslyInstrumented) {\n      const messageSpan = createMessageSpan(options.parentSpan, this._context.config);\n      eventData = instrumentEventData(eventData, messageSpan);\n      spanContext = messageSpan.context();\n      messageSpan.end();\n    }\n\n    // Convert EventData to RheaMessage.\n    const amqpMessage = toRheaMessage(eventData, this._partitionKey);\n    amqpMessage.body = defaultDataTransformer.encode(eventData.body);\n    const encodedMessage = message.encode(amqpMessage);\n\n    let currentSize = this._sizeInBytes;\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations that are taken from the 1st message.\n    if (this.count === 0) {\n      if (amqpMessage.message_annotations) {\n        this._batchAnnotations = amqpMessage.message_annotations;\n      }\n\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch([], this._batchAnnotations).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The event will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuid } from \"uuid\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport {\n  AmqpError,\n  AwaitableSender,\n  AwaitableSenderOptions,\n  EventContext,\n  OnAmqpEvent,\n  message,\n  Message as RheaMessage\n} from \"rhea-promise\";\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  defaultLock,\n  retry,\n  translate\n} from \"@azure/core-amqp\";\nimport { EventData, toRheaMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { EventHubProducerOptions } from \"./models/private\";\nimport { SendOptions } from \"./models/public\";\n\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { EventDataBatch, isEventDataBatch } from \"./eventDataBatch\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\n\n/**\n * Describes the EventHubSender that will send event data to EventHub.\n * @internal\n */\nexport class EventHubSender extends LinkEntity {\n  /**\n   * The unique lock name per connection that is used to acquire the\n   * lock for establishing a sender link by an entity on that connection.\n   * @readonly\n   */\n  readonly senderLock: string = `sender-${uuid()}`;\n  /**\n   * The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEvent;\n  /**\n   * The AMQP sender link.\n   */\n  private _sender?: AwaitableSender;\n\n  /**\n   * Creates a new EventHubSender instance.\n   * @hidden\n   * @param context - The connection context.\n   * @param partitionId - The EventHub partition id to which the sender\n   * wants to send the event data.\n   */\n  constructor(context: ConnectionContext, partitionId?: string) {\n    super(context, {\n      name: context.config.getSenderAddress(partitionId),\n      partitionId: partitionId\n    });\n    this.address = context.config.getSenderAddress(partitionId);\n    this.audience = context.config.getSenderAudience(partitionId);\n\n    this._onAmqpError = (eventContext: EventContext) => {\n      const senderError = eventContext.sender && eventContext.sender.error;\n      logger.verbose(\n        \"[%s] 'sender_error' event occurred on the sender '%s' with address '%s'. \" +\n          \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        senderError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onSessionError = (eventContext: EventContext) => {\n      const sessionError = eventContext.session && eventContext.session.error;\n      logger.verbose(\n        \"[%s] 'session_error' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"The associated error is: %O\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sessionError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onAmqpClose = async (eventContext: EventContext) => {\n      const sender = this._sender || eventContext.sender!;\n      logger.verbose(\n        \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s'. \" +\n          \"Value for isItselfClosed on the receiver is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sender ? sender.isItselfClosed().toString() : undefined,\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          logger.verbose(\n            \"[%s] Error when closing sender [%s] after 'sender_close' event: %O\",\n            this._context.connectionId,\n            this.name,\n            err\n          );\n        });\n      }\n    };\n\n    this._onSessionClose = async (eventContext: EventContext) => {\n      const sender = this._sender || eventContext.sender!;\n      logger.verbose(\n        \"[%s] 'session_close' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"Value for isSessionItselfClosed on the session is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        this._context.connectionId,\n        this.name,\n        this.address,\n        sender ? sender.isSessionItselfClosed().toString() : undefined,\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          logger.verbose(\n            \"[%s] Error when closing sender [%s] after 'session_close' event: %O\",\n            this._context.connectionId,\n            this.name,\n            err\n          );\n        });\n      }\n    };\n  }\n\n  /**\n   * Deletes the sender from the context. Clears the token renewal timer. Closes the sender link.\n   * @hidden\n   * @returns Promise<void>\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._sender) {\n        logger.info(\n          \"[%s] Closing the Sender for the entity '%s'.\",\n          this._context.connectionId,\n          this._context.config.entityPath\n        );\n        const senderLink = this._sender;\n        this._deleteFromCache();\n        await this._closeLink(senderLink);\n      }\n    } catch (err) {\n      const msg = `[${this._context.connectionId}] An error occurred while closing sender ${this.name}: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @hidden\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this._sender! && this._sender!.isOpen();\n    logger.verbose(\n      \"[%s] Sender '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns Promise<number>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<number> {\n    const abortSignal = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    if (this.isOpen()) {\n      return this._sender!.maxMessageSize;\n    }\n    return new Promise<number>(async (resolve, reject) => {\n      const rejectOnAbort = (): void => {\n        const desc: string = `[${this._context.connectionId}] The create batch operation has been cancelled by the user.`;\n        // Cancellation is user-intented, so treat as info instead of warning.\n        logger.info(desc);\n        const error = new AbortError(`The create batch operation has been cancelled by the user.`);\n        reject(error);\n      };\n\n      const onAbort = (): void => {\n        if (abortSignal) {\n          abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n        rejectOnAbort();\n      };\n\n      if (abortSignal) {\n        // the aborter may have been triggered between request attempts\n        // so check if it was triggered and reject if needed.\n        if (abortSignal.aborted) {\n          return rejectOnAbort();\n        }\n        abortSignal.addEventListener(\"abort\", onAbort);\n      }\n      try {\n        logger.verbose(\n          \"Acquiring lock %s for initializing the session, sender and \" +\n            \"possibly the connection.\",\n          this.senderLock\n        );\n        const senderOptions = this._createSenderOptions(Constants.defaultOperationTimeoutInMs);\n        await defaultLock.acquire(this.senderLock, () => {\n          const config: RetryConfig<void> = {\n            operation: () => this._init(senderOptions),\n            connectionId: this._context.connectionId,\n            operationType: RetryOperationType.senderLink,\n            abortSignal: abortSignal,\n            retryOptions: retryOptions\n          };\n\n          return retry<void>(config);\n        });\n        resolve(this._sender!.maxMessageSize);\n      } catch (err) {\n        logger.warning(\n          \"[%s] An error occurred while creating the sender %s\",\n          this._context.connectionId,\n          this.name\n        );\n        logErrorStackTrace(err);\n        reject(err);\n      } finally {\n        if (abortSignal) {\n          abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n      }\n    });\n  }\n\n  /**\n   * Send a batch of EventData to the EventHub. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @hidden\n   * @param events -  An array of EventData objects to be sent in a Batch message.\n   * @param options - Options to control the way the events are batched along with request options\n   */\n  async send(\n    events: EventData[] | EventDataBatch,\n    options?: SendOptions & EventHubProducerOptions\n  ): Promise<void> {\n    try {\n      logger.info(\n        \"[%s] Sender '%s', trying to send EventData[].\",\n        this._context.connectionId,\n        this.name\n      );\n\n      let encodedBatchMessage: Buffer | undefined;\n      if (isEventDataBatch(events)) {\n        if (events.count === 0) {\n          logger.info(\n            `[${this._context.connectionId}] Empty batch was passsed. No events to send.`\n          );\n          return;\n        }\n        encodedBatchMessage = events._generateMessage();\n      } else {\n        if (events.length === 0) {\n          logger.info(`[${this._context.connectionId}] Empty array was passed. No events to send.`);\n          return;\n        }\n        const partitionKey = (options && options.partitionKey) || undefined;\n        const messages: RheaMessage[] = [];\n        // Convert EventData to RheaMessage.\n        for (let i = 0; i < events.length; i++) {\n          const rheaMessage = toRheaMessage(events[i], partitionKey);\n          rheaMessage.body = defaultDataTransformer.encode(events[i].body);\n          messages[i] = rheaMessage;\n        }\n        // Encode every amqp message and then convert every encoded message to amqp data section\n        const batchMessage: RheaMessage = {\n          body: message.data_sections(messages.map(message.encode))\n        };\n\n        // Set message_annotations of the first message as\n        // that of the envelope (batch message).\n        if (messages[0].message_annotations) {\n          batchMessage.message_annotations = messages[0].message_annotations;\n        }\n\n        // Finally encode the envelope (batch message).\n        encodedBatchMessage = message.encode(batchMessage);\n      }\n      logger.info(\n        \"[%s] Sender '%s', sending encoded batch message.\",\n        this._context.connectionId,\n        this.name,\n        encodedBatchMessage\n      );\n      return await this._trySendBatch(encodedBatchMessage, options);\n    } catch (err) {\n      logger.warning(\n        `An error occurred while sending the batch message ${err?.name}: ${err?.message}`\n      );\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  private _deleteFromCache(): void {\n    this._sender = undefined;\n    delete this._context.senders[this.name];\n    logger.verbose(\n      \"[%s] Deleted the sender '%s' with address '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name,\n      this.address\n    );\n  }\n\n  private _createSenderOptions(timeoutInMs: number, newName?: boolean): AwaitableSenderOptions {\n    if (newName) this.name = `${uuid()}`;\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose,\n      sendTimeoutInSeconds: timeoutInMs / 1000\n    };\n    logger.verbose(\"Creating sender with options: %O\", srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to EventHub if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   * @hidden\n   * @param rheaMessage - The message to be sent to EventHub.\n   * @returns Promise<void>\n   */\n  private _trySendBatch(\n    rheaMessage: RheaMessage | Buffer,\n    options: SendOptions & EventHubProducerOptions = {}\n  ): Promise<void> {\n    const abortSignal: AbortSignalLike | undefined = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    const timeoutInMs = getRetryAttemptTimeoutInMs(retryOptions);\n    retryOptions.timeoutInMs = timeoutInMs;\n    const sendEventPromise = (): Promise<void> =>\n      new Promise<void>(async (resolve, reject) => {\n        const rejectOnAbort = (): void => {\n          const desc: string =\n            `[${this._context.connectionId}] The send operation on the Sender \"${this.name}\" with ` +\n            `address \"${this.address}\" has been cancelled by the user.`;\n          // Cancellation is user-intended, so log to info instead of warning.\n          logger.info(desc);\n          return reject(new AbortError(\"The send operation has been cancelled by the user.\"));\n        };\n\n        if (abortSignal && abortSignal.aborted) {\n          // operation has been cancelled, so exit quickly\n          return rejectOnAbort();\n        }\n\n        const removeListeners = (): void => {\n          clearTimeout(waitTimer); // eslint-disable-line @typescript-eslint/no-use-before-define\n          if (abortSignal) {\n            abortSignal.removeEventListener(\"abort\", onAborted); // eslint-disable-line @typescript-eslint/no-use-before-define\n          }\n        };\n\n        const onAborted = (): void => {\n          removeListeners();\n          return rejectOnAbort();\n        };\n\n        if (abortSignal) {\n          abortSignal.addEventListener(\"abort\", onAborted);\n        }\n\n        const actionAfterTimeout = (): void => {\n          removeListeners();\n          const desc: string =\n            `[${this._context.connectionId}] Sender \"${this.name}\" with ` +\n            `address \"${this.address}\", was not able to send the message right now, due ` +\n            `to operation timeout.`;\n          logger.warning(desc);\n          const e: Error = {\n            name: \"OperationTimeoutError\",\n            message: desc\n          };\n          return reject(translate(e));\n        };\n\n        const waitTimer = setTimeout(actionAfterTimeout, timeoutInMs);\n        const initStartTime = Date.now();\n        if (!this.isOpen()) {\n          logger.verbose(\n            \"Acquiring lock %s for initializing the session, sender and \" +\n              \"possibly the connection.\",\n            this.senderLock\n          );\n\n          try {\n            const senderOptions = this._createSenderOptions(timeoutInMs);\n            await defaultLock.acquire(this.senderLock, () => {\n              return this._init(senderOptions);\n            });\n          } catch (err) {\n            removeListeners();\n            const translatedError = translate(err);\n            logger.warning(\n              \"[%s] An error occurred while creating the sender %s: %s\",\n              this._context.connectionId,\n              this.name,\n              `${translatedError?.name}: ${translatedError?.message}`\n            );\n            logErrorStackTrace(translatedError);\n            return reject(translatedError);\n          }\n        }\n        const timeTakenByInit = Date.now() - initStartTime;\n\n        logger.verbose(\n          \"[%s] Sender '%s', credit: %d available: %d\",\n          this._context.connectionId,\n          this.name,\n          this._sender!.credit,\n          this._sender!.session.outgoing.available()\n        );\n        if (this._sender!.sendable()) {\n          logger.verbose(\n            \"[%s] Sender '%s', sending message with id '%s'.\",\n            this._context.connectionId,\n            this.name\n          );\n          if (timeoutInMs <= timeTakenByInit) {\n            actionAfterTimeout();\n            return;\n          }\n          try {\n            this._sender!.sendTimeoutInSeconds = (timeoutInMs - timeTakenByInit) / 1000;\n            const delivery = await this._sender!.send(rheaMessage, undefined, 0x80013700);\n            logger.info(\n              \"[%s] Sender '%s', sent message with delivery id: %d\",\n              this._context.connectionId,\n              this.name,\n              delivery.id\n            );\n            return resolve();\n          } catch (err) {\n            const translatedError = translate(err.innerError || err);\n            logger.warning(\n              \"[%s] An error occurred while sending the message %s\",\n              this._context.connectionId,\n              `${translatedError?.name}: ${translatedError?.message}`\n            );\n            logErrorStackTrace(translatedError);\n            return reject(translatedError);\n          } finally {\n            removeListeners();\n          }\n        } else {\n          // let us retry to send the message after some time.\n          const msg =\n            `[${this._context.connectionId}] Sender \"${this.name}\", ` +\n            `cannot send the message right now. Please try later.`;\n          logger.warning(msg);\n          const amqpError: AmqpError = {\n            condition: ErrorNameConditionMapper.SenderBusyError,\n            description: msg\n          };\n          reject(translate(amqpError));\n        }\n      });\n\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.sendMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions\n    };\n    return retry<void>(config);\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   * @hidden\n   */\n  private async _init(options: AwaitableSenderOptions): Promise<void> {\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        this.isConnecting = true;\n\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        await this._negotiateClaim();\n\n        logger.verbose(\n          \"[%s] Trying to create sender '%s'...\",\n          this._context.connectionId,\n          this.name\n        );\n\n        this._sender = await this._context.connection.createAwaitableSender(options);\n        this.isConnecting = false;\n        logger.verbose(\n          \"[%s] Sender '%s' created with sender options: %O\",\n          this._context.connectionId,\n          this.name,\n          options\n        );\n        this._sender.setMaxListeners(1000);\n\n        // It is possible for someone to close the sender and then start it again.\n        // Thus make sure that the sender is present in the client cache.\n        if (!this._context.senders[this.name]) this._context.senders[this.name] = this;\n        await this._ensureTokenRenewal();\n      } else {\n        logger.verbose(\n          \"[%s] The sender '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      const translatedError = translate(err);\n      logger.warning(\n        \"[%s] An error occurred while creating the sender %s: %s\",\n        this._context.connectionId,\n        this.name,\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Creates a new sender to the given event hub, and optionally to a given partition if it is\n   * not present in the context or returns the one present in the context.\n   * @hidden\n   * @static\n   * @param partitionId - Partition ID to which it will send event data.\n   */\n  static create(context: ConnectionContext, partitionId?: string): EventHubSender {\n    const ehSender: EventHubSender = new EventHubSender(context, partitionId);\n    if (!context.senders[ehSender.name]) {\n      context.senders[ehSender.name] = ehSender;\n    }\n    return context.senders[ehSender.name];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, TokenCredential } from \"@azure/core-auth\";\nimport { getTracer } from \"@azure/core-tracing\";\nimport { CanonicalCode, Link, Span, SpanContext, SpanKind } from \"@opentelemetry/api\";\nimport { ConnectionContext, createConnectionContext } from \"./connectionContext\";\nimport { instrumentEventData, TRACEPARENT_PROPERTY } from \"./diagnostics/instrumentEventData\";\nimport { createMessageSpan } from \"./diagnostics/messageSpan\";\nimport { EventData } from \"./eventData\";\nimport { EventDataBatch, EventDataBatchImpl, isEventDataBatch } from \"./eventDataBatch\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport {\n  CreateBatchOptions,\n  EventHubClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  SendBatchOptions\n} from \"./models/public\";\nimport { throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { isDefined } from \"./util/typeGuards\";\nimport { getParentSpan, OperationOptions } from \"./util/operationOptions\";\n\n/**\n * The `EventHubProducerClient` class is used to send events to an Event Hub.\n *\n * There are multiple ways to create an `EventHubProducerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass an options bag to configure the retry policy or proxy settings.\n *\n */\nexport class EventHubProducerClient {\n  /**\n   * Describes the amqp connection context for the client.\n   */\n  private _context: ConnectionContext;\n\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubClientOptions;\n  /**\n   * Map of partitionId to senders\n   */\n  private _sendersMap: Map<string, EventHubSender>;\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, options?: EventHubClientOptions); // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions); // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service. See &commat;azure/identity for creating the credentials.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential,\n    options?: EventHubClientOptions // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    eventHubNameOrOptions2?: string | EventHubClientOptions,\n    credentialOrOptions3?: TokenCredential | EventHubClientOptions,\n    options4?: EventHubClientOptions // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  ) {\n    this._context = createConnectionContext(\n      fullyQualifiedNamespaceOrConnectionString1,\n      eventHubNameOrOptions2,\n      credentialOrOptions3,\n      options4\n    );\n    if (typeof eventHubNameOrOptions2 !== \"string\") {\n      this._clientOptions = eventHubNameOrOptions2 || {};\n    } else if (!isTokenCredential(credentialOrOptions3)) {\n      this._clientOptions = credentialOrOptions3 || {};\n    } else {\n      this._clientOptions = options4 || {};\n    }\n\n    this._sendersMap = new Map();\n  }\n\n  /**\n   * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.\n   * The batch can be passed to the {@link sendBatch} method of the `EventHubProducerClient` to be sent to Azure Event Hubs.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * let batch = await client.createBatch();\n   * for (let i = 0; i < messages.length; i++) {\n   *  if (!batch.tryAdd(messages[i])) {\n   *    await client.sendBatch(batch);\n   *    batch = await client.createBatch();\n   *    if (!batch.tryAdd(messages[i])) {\n   *      throw new Error(\"Message too big to fit\")\n   *    }\n   *    if (i === messages.length - 1) {\n   *      await client.sendBatch(batch);\n   *    }\n   *   }\n   * }\n   * ```\n   *\n   * @param options -  Configures the behavior of the batch.\n   * - `partitionKey`  : A value that is hashed and used by the Azure Event Hubs service to determine the partition to which\n   * the events need to be sent.\n   * - `partitionId`   : Id of the partition to which the batch of events need to be sent.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   * - `abortSignal`   : A signal the request to cancel the operation.\n   * @returns Promise<EventDataBatch>\n   * @throws Error if both `partitionId` and `partitionKey` are set in the options.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal in the options.\n   */\n  async createBatch(options: CreateBatchOptions = {}): Promise<EventDataBatch> {\n    throwErrorIfConnectionClosed(this._context);\n\n    if (isDefined(options.partitionId) && isDefined(options.partitionKey)) {\n      throw new Error(\"partitionId and partitionKey cannot both be set when creating a batch\");\n    }\n\n    let sender = this._sendersMap.get(\"\");\n    if (!sender) {\n      sender = EventHubSender.create(this._context);\n      this._sendersMap.set(\"\", sender);\n    }\n\n    let maxMessageSize = await sender.getMaxMessageSize({\n      retryOptions: this._clientOptions.retryOptions,\n      abortSignal: options.abortSignal\n    });\n\n    if (options.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`\n        );\n        logger.warning(`[${this._context.connectionId}] ${error.message}`);\n        logErrorStackTrace(error);\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new EventDataBatchImpl(\n      this._context,\n      maxMessageSize,\n      options.partitionKey,\n      options.partitionId\n    );\n  }\n\n  /**\n   * Sends an array of events to the associated Event Hub.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * await client.sendBatch(messages);\n   * ```\n   *\n   * @param batch - An array of {@link EventData}.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   * - `partitionId`  : The partition this batch will be sent to. If set, `partitionKey` can not be set.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment. If set, `partitionId` can not be set.\n   *\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  async sendBatch(batch: EventData[], options?: SendBatchOptions): Promise<void>;\n  /**\n   * Sends a batch of events to the associated Event Hub.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * let batch = await client.createBatch();\n   * for (let i = 0; i < messages.length; i++) {\n   *  if (!batch.tryAdd(messages[i])) {\n   *    await client.sendBatch(batch);\n   *    batch = await client.createBatch();\n   *    if (!batch.tryAdd(messages[i])) {\n   *      throw new Error(\"Message too big to fit\")\n   *    }\n   *    if (i === messages.length - 1) {\n   *      await client.sendBatch(batch);\n   *    }\n   *   }\n   * }\n   * ```\n   * @param batch - A batch of events that you can create using the {@link createBatch} method.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   *\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  async sendBatch(batch: EventDataBatch, options?: OperationOptions): Promise<void>; // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  async sendBatch(\n    batch: EventDataBatch | EventData[],\n    options: SendBatchOptions | OperationOptions = {}\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"sendBatch\", \"batch\", batch);\n\n    let partitionId: string | undefined;\n    let partitionKey: string | undefined;\n\n    // link message span contexts\n    let spanContextsToLink: SpanContext[] = [];\n\n    if (isEventDataBatch(batch)) {\n      // For batches, partitionId and partitionKey would be set on the batch.\n      partitionId = batch.partitionId;\n      partitionKey = batch.partitionKey;\n      const unexpectedOptions = options as SendBatchOptions;\n      if (unexpectedOptions.partitionKey && partitionKey !== unexpectedOptions.partitionKey) {\n        throw new Error(\n          `The partitionKey (${unexpectedOptions.partitionKey}) set on sendBatch does not match the partitionKey (${partitionKey}) set when creating the batch.`\n        );\n      }\n      if (unexpectedOptions.partitionId && unexpectedOptions.partitionId !== partitionId) {\n        throw new Error(\n          `The partitionId (${unexpectedOptions.partitionId}) set on sendBatch does not match the partitionId (${partitionId}) set when creating the batch.`\n        );\n      }\n\n      spanContextsToLink = batch._messageSpanContexts;\n    } else {\n      if (!Array.isArray(batch)) {\n        batch = [batch];\n      }\n\n      // For arrays of events, partitionId and partitionKey would be set in the options.\n      const expectedOptions = options as SendBatchOptions;\n      partitionId = expectedOptions.partitionId;\n      partitionKey = expectedOptions.partitionKey;\n\n      for (let i = 0; i < batch.length; i++) {\n        const event = batch[i];\n        if (!event.properties || !event.properties[TRACEPARENT_PROPERTY]) {\n          const messageSpan = createMessageSpan(\n            getParentSpan(options.tracingOptions),\n            this._context.config\n          );\n          // since these message spans are created from same context as the send span,\n          // these message spans don't need to be linked.\n          // replace the original event with the instrumented one\n          batch[i] = instrumentEventData(batch[i], messageSpan);\n          messageSpan.end();\n        }\n      }\n    }\n    if (isDefined(partitionId) && isDefined(partitionKey)) {\n      throw new Error(\n        `The partitionId (${partitionId}) and partitionKey (${partitionKey}) cannot both be specified.`\n      );\n    }\n\n    if (isDefined(partitionId)) {\n      partitionId = String(partitionId);\n    }\n    if (isDefined(partitionKey)) {\n      partitionKey = String(partitionKey);\n    }\n\n    let sender = this._sendersMap.get(partitionId || \"\");\n    if (!sender) {\n      sender = EventHubSender.create(this._context, partitionId);\n      this._sendersMap.set(partitionId || \"\", sender);\n    }\n\n    const sendSpan = this._createSendSpan(\n      getParentSpan(options.tracingOptions),\n      spanContextsToLink\n    );\n\n    try {\n      const result = await sender.send(batch, {\n        ...options,\n        partitionId,\n        partitionKey,\n        retryOptions: this._clientOptions.retryOptions\n      });\n      sendSpan.setStatus({ code: CanonicalCode.OK });\n      return result;\n    } catch (error) {\n      sendSpan.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: error.message\n      });\n      throw error;\n    } finally {\n      sendSpan.end();\n    }\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    await this._context.close();\n\n    for (const pair of this._sendersMap) {\n      await pair[1].close();\n    }\n    this._sendersMap.clear();\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._context.managementSession!.getEventHubProperties({\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._context\n      .managementSession!.getEventHubProperties({\n        ...options,\n        retryOptions: this._clientOptions.retryOptions\n      })\n      .then((eventHubProperties) => {\n        return eventHubProperties.partitionIds;\n      });\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._context.managementSession!.getPartitionProperties(partitionId, {\n      ...options,\n      retryOptions: this._clientOptions.retryOptions\n    });\n  }\n\n  private _createSendSpan(\n    parentSpan?: Span | SpanContext | null,\n    spanContextsToLink: SpanContext[] = []\n  ): Span {\n    const links: Link[] = spanContextsToLink.map((context) => {\n      return {\n        context\n      };\n    });\n    const tracer = getTracer();\n    const span = tracer.startSpan(\"Azure.EventHubs.send\", {\n      kind: SpanKind.CLIENT,\n      parent: parentSpan,\n      links\n    });\n\n    span.setAttribute(\"az.namespace\", \"Microsoft.EventHub\");\n    span.setAttribute(\"message_bus.destination\", this._context.config.entityPath);\n    span.setAttribute(\"peer.address\", this._context.config.host);\n\n    return span;\n  }\n}\n"],"names":["createClientLogger","os.type","os.release","parseConnectionString","Buffer","uuid","defaultLock","TokenType","Constants","CanonicalCode","translate","RequestResponseLink","SenderEvents","ReceiverEvents","AbortError","generate_uuid","RetryOperationType","retry","getTracer","SpanKind","ConnectionConfig","ConnectionContextBase","ConnectionEvents","isTokenCredential","CloseReason","ErrorNameConditionMapper","message","delay","types","getTraceParentHeader","extractSpanContextFromTraceParentHeader","AbortController"],"mappings":"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"}